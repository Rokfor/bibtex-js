{"version":3,"sources":["../../sources/lib/LatexTree.js"],"names":["Latex","require","LatexStyle","SyntaxTree","module","exports","rootToken","source","Token","TypeError","opt_initialProperties","undefined","Object","superInitialProperties","create","parentNode","parentToken","childNodes","childTokens","skipNodeClass","Node","defineProperties","prototype","lexeme","value","enumerable","parentNodeClass_","SymbolToken","initialProperties","symbol","Symbol","defineProperty","pattern","iParameter","nPatternChars","length","iPatternChar","patternChar","parameterToken","childNode","toString","ParameterToken","hasBrackets","hasSpacePrefix","parameter","symbolToken","childIndex","CommandToken","command","Command","name","EnvironmentToken","environment","Environment","beginCommandToken","endCommandToken","bodyToken","call","EnvironmentBodyToken","beginToken","endToken","SpaceToken","lineBreakCount","isFinite","Lexeme","SPACE","PARAGRAPH_SEPARATOR","SourceToken"],"mappings":"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","file":"LatexTree.js","sourcesContent":["/**\n * @fileoverview LaTeX syntax tree structure elements\n * This file is a part of TeXnous project.\n *\n * @copyright TeXnous project team (http://texnous.com) 2016\n * @license LGPL-3.0\n *\n * This library is free software; you can redistribute it and/or modify it under the terms of the\n * GNU Lesser General Public License as published by the Free Software Foundation; either version 3\n * of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License along with this library;\n * if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n * 02111-1307, USA.\n */\n\n'use strict';\n\n/** @module */\n\n\n/** @external Latex */\nconst Latex = require('./Latex'); // general LaTeX definitions\n/** @external LatexStyle*/\nconst LatexStyle = require('./LatexStyle'); // LaTeX style structures\n/** @external SyntaxTree */\nconst SyntaxTree = require('./SyntaxTree'); // syntax tree structure elements\n\n\n/**\n * LaTeX syntax tree structure\n * @class\n * @extends SyntaxTree\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n */\nmodule.exports = class extends SyntaxTree {\n  //noinspection JSUnusedGlobalSymbols\n  /**\n   * Constructor\n   * @param {!Token} rootToken the root token (must have no parent and no tree)\n   * @param {string} source the sources text that has this syntax tree\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n   */\n  constructor(rootToken, source) {\n    if (!(rootToken instanceof Token))\n      throw new TypeError('\"rootToken\" isn\\'t a LatexTree.Token instance');\n    super(rootToken, source); // the superclass constructor\n  }\n};\n\n\n\n/**\n * LaTeX syntax tree token base properties\n * @interface TokenProperties\n * @property {(?Token|undefined)} parentToken - The parent token or null if there is no parent\n * @property {(!Array.<Token>|undefined)} childTokens - The list of the child tokens\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n */\n\n\n\n/**\n * LaTeX syntax tree token base structure\n * @class\n * @extends SyntaxTree.Node\n * @property {(Latex.Lexeme|null)} lexeme - The logical lexeme of the token\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n */\nconst Token = module.exports['Token'] = class extends SyntaxTree.Node {\n  //noinspection JSUnusedGlobalSymbols\n  /**\n   * Constructor\n   * @param {!TokenProperties=} opt_initialProperties the initial property values\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n   */\n  constructor(opt_initialProperties) {\n    if (opt_initialProperties === undefined) { // if the initial properties are not set\n      super(); // superclass constructor\n    } else if (opt_initialProperties instanceof Object) { // if the initial properties are set\n      // superclass constructor\n      // superclass initial properties\n      let superInitialProperties = Object.create(opt_initialProperties);\n      superInitialProperties.parentNode = opt_initialProperties.parentToken;\n      superInitialProperties.childNodes = opt_initialProperties.childTokens;\n      super(superInitialProperties);\n    } else { // if the initial properties are in unsupported type\n      throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n    }\n  }\n\n\n  /**\n   * Get the string representation of this node\n   * @param {boolean=false} skipNodeClass\n   *        true to not include the node class name into the output, false otherwise\n   * @return {string} the sources string\n   * @override\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n   */\n  toString(skipNodeClass) {\n    return skipNodeClass ? super.toString(true) : 'LatexTree.Token{' + super.toString(true) + '}';\n  }\n};\nObject.defineProperties(Token.prototype, { // default properties\n  lexeme: { value: null, enumerable: true }, // no lexeme\n  parentNodeClass_: { value: Token } // parent node must be an EnvironmentToken instance\n});\n\n\n\n/**\n * LaTeX symbol token properties\n * @interface SymbolTokenProperties\n * @extends TokenProperties\n * @property {!LatexStyle.Symbol|undefined} symbol -\n *           The LaTeX symbol or undefined if the symbol is unrecognized\n * @property {string|undefined} pattern - The pattern that corresponds to the unrecognized symbol\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n */\n\n\n\n/**\n * LaTeX symbol token structure\n * @class\n * @extends Token\n * @property {?LatexStyle.Symbol} symbol -\n *           The corresponding LaTeX symbol or null if the symbol is unrecognized\n * @property {string} pattern - The symbol LaTeX pattern\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n */\nconst SymbolToken = module.exports['SymbolToken'] = class extends Token {\n  //noinspection JSUnusedGlobalSymbols\n  /**\n   * Constructor\n   * @param {!SymbolTokenProperties} initialProperties the initial property values\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n   */\n  constructor(initialProperties) {\n    if (!(initialProperties instanceof Object))\n      throw new TypeError ('\"initialProperties\" isn\\'t an Object instance');\n    super(initialProperties); // the superclass constructor\n    if (initialProperties.symbol) { // if the symbol is defined\n      if (!(initialProperties.symbol instanceof LatexStyle.Symbol))\n        throw new TypeError('\"initialProperties.symbol\" isn\\'t a LatexStyle.Symbol instance');\n      // store the symbol\n      Object.defineProperty(this, 'symbol', {value: initialProperties.symbol, enumerable: true});\n    } else { // if the symbol isn't defined\n      if (typeof initialProperties.pattern !== 'string')\n        throw new TypeError('\"initialProperties.pattern\" isn\\'t a string');\n      // store the unrecognized pattern\n      Object.defineProperty(this, 'pattern', { value: initialProperties.pattern });\n    }\n  }\n\n\n  /**\n   * Get the logical lexeme\n   * @return {(Latex.Lexeme|null)} the lexeme or null if the lexeme isn't defined\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n   */\n  get lexeme () {\n    //noinspection JSUnresolvedVariable\n    return this.symbol ? this.symbol.lexeme : null;\n  }\n\n\n  /**\n   * Get the symbol LaTeX pattern\n   * @return {string} the symbol pattern\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n   */\n  get pattern () {\n    //noinspection JSUnresolvedVariable\n    return this.symbol.pattern;\n  }\n\n\n  /**\n   * Get the string representation of this node\n   * @param {boolean=false} skipNodeClass\n   *        true to not include the node class name into the output, false otherwise\n   * @return {string} the sources string\n   * @override\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n   */\n  toString(skipNodeClass) {\n    let source = '';\n    let iParameter = 0; // the parameter iterator\n    //noinspection JSUnresolvedVariable\n    let pattern = this.pattern; // LaTeX input pattern\n    // for all the pattern chars\n    for (\n      let nPatternChars = pattern.length, iPatternChar = 0;\n      iPatternChar < nPatternChars;\n      ++iPatternChar\n    ) {\n      let patternChar = pattern[iPatternChar]; // the pattern char\n      if (patternChar === '#') { // if a parameter place\n        ++iPatternChar; // go to the next pattern char\n        let parameterToken = this.childNode(iParameter++); // try to get the parameter token\n        source += parameterToken ? parameterToken.toString(true) : '??';\n      } else { // if the ordinary pattern char\n        source += patternChar;\n      }\n    }\n    return skipNodeClass ?\n      source :\n      'LatexTree.SymbolToken' + (this.symbol ? '' : '[?]') + '{' + source + '}';\n  }\n};\nObject.defineProperties(SymbolToken.prototype, { // default properties\n  symbol: { value: null, enumerable: true } // no symbol token\n});\nObject.defineProperties(SymbolToken.prototype, { // make getters and setters enumerable\n  pattern: { enumerable: true }\n});\n\n\n\n/**\n * LaTeX parameter token properties\n * @interface ParameterTokenProperties\n * @extends TokenProperties\n * @property {boolean} hasBrackets -\n *           True if the parameter is bounded by the logical brackets, false otherwise\n * @property {boolean} hasSpacePrefix -\n *           True if the parameter is prefixed by a space, false otherwise\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n */\n\n\n\n/**\n * LaTeX parameter token structure\n * @class\n * @extends Token\n * @property {boolean} hasBrackets -\n *           True if the parameter is bounded by the logical brackets, false otherwise\n * @property {boolean} hasSpacePrefix -\n *           True if the parameter is prefixed by a space, false otherwise\n * @property {?LatexStyle.Parameter} parameter - The corresponding LaTeX parameter\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n */\nconst ParameterToken = module.exports['ParameterToken'] = class extends Token {\n  //noinspection JSUnusedGlobalSymbols\n  /**\n   * Constructor\n   * @param {!ParameterTokenProperties} initialProperties the initial property values\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n   */\n  constructor(initialProperties) {\n    if (!(initialProperties instanceof Object))\n      throw new TypeError ('\"initialProperties\" isn\\'t an Object instance');\n    super(initialProperties); // the superclass constructor\n    if (!initialProperties.hasBrackets) // if there are no bounding brackets\n      // store this fact\n      Object.defineProperty(this, 'hasBrackets', { value: false, enumerable: true });\n    if (initialProperties.hasSpacePrefix) // if there is a space before\n      // store this fact\n      Object.defineProperty(this, 'hasSpacePrefix', { value: true, enumerable: true });\n  }\n\n\n  /**\n   * Get the logical lexeme\n   * @return {(Latex.Lexeme|null)} the lexeme or null if the lexeme isn't defined\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n   */\n  get lexeme () { return this.parameter && this.parameter.lexeme }\n\n\n  /**\n   * Get the corresponding LaTeX parameter description\n   * @return {?LatexStyle.Parameter}\n   *         the LaTeX parameter or null of there is parent symbol or such a parameter\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n   */\n  get parameter () {\n    /** @type {?SymbolToken} */\n    let symbolToken = this.parentNode; // get the symbol token\n    //noinspection JSUnresolvedFunction\n    return symbolToken && symbolToken.symbol.parameter(symbolToken.childIndex(this));\n  }\n\n\n  /**\n   * Get the string representation of this node\n   * @param {boolean=false} skipNodeClass\n   *        true to not include the node class name into the output, false otherwise\n   * @return {string} the sources string\n   * @override\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n   */\n  toString(skipNodeClass) {\n    let source = this.hasSpacePrefix ? ' ' : '';\n    source += this.hasBrackets ? '{' + super.toString(true) + '}' : super.toString(true);\n    return skipNodeClass ? source : 'LatexTree.ParameterToken{' + source + '}';\n  }\n};\nObject.defineProperties(ParameterToken.prototype, { // default properties\n  hasBrackets: { value: true, enumerable: true }, // there are bounding brackets\n  hasSpacePrefix: { value: false, enumerable: true }, // there is no space before\n  parentNodeClass_: { value: SymbolToken } // parent node must be a SymbolToken instance\n});\nObject.defineProperties(ParameterToken.prototype, { // make getters and setters enumerable\n  parameter: { enumerable: true }\n});\n\n\n\n/**\n * LaTeX command token properties\n * @interface CommandTokenProperties\n * @extends TokenProperties\n * @property {!LatexStyle.Command|undefined} command -\n *           The LaTeX command or undefined if the command is unrecognized\n * @property {string|undefined} name - The name that corresponds to the unrecognized command\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n */\n\n\n\n/**\n * LaTeX command token structure\n * @class\n * @extends SymbolToken\n * @property {!LatexStyle.Command} command -\n *           The corresponding LaTeX command or null if the command is unrecognized\n * @property {string|undefined} name - The LaTeX command name\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n */\nconst CommandToken = module.exports['CommandToken'] = class extends SymbolToken {\n  //noinspection JSUnusedGlobalSymbols\n  /**\n   * Constructor\n   * @param {!CommandTokenProperties} initialProperties the initial property values\n   */\n  constructor(initialProperties) {\n    if (!(initialProperties instanceof Object))\n      throw new TypeError ('\"initialProperties\" isn\\'t an Object instance');\n    // copy the initial properties for the superclass\n    let superInitialProperties = Object.create(initialProperties);\n    if (initialProperties.command) { // if the command is defined\n      if (!(initialProperties.command instanceof LatexStyle.Command))\n        throw new TypeError('\"initialProperties.command\" isn\\'t a LatexStyle.Command instance');\n      // the command is the symbol for the superclass\n      superInitialProperties.symbol = initialProperties.command;\n      super(superInitialProperties); // the superclass constructor\n    } else { // if the command isn't defined\n      if (typeof initialProperties.name !== 'string')\n        throw new TypeError('\"initialProperties.name\" isn\\'t a string');\n      superInitialProperties.pattern = '';\n      super(superInitialProperties); // the superclass constructor\n      // store the unrecognized name\n      Object.defineProperty(this, 'name', { value: initialProperties.name });\n    }\n  }\n\n\n  /**\n   * Get the LaTeX command\n   * @return {!LatexStyle.Command} the command description\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n   */\n  get command () { return this.symbol }\n\n\n  /**\n   * Get the LaTeX command name\n   * @return {string} the command name\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n   */\n  get name () { return this.command.name }\n\n  /**\n   * Get the string representation of this node\n   * @param {boolean=false} skipNodeClass\n   *        true to not include the node class name into the output, false otherwise\n   * @return {string} the sources string\n   * @override\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n   */\n  toString(skipNodeClass) {\n   let source = '\\\\' + this.name + super.toString(true);\n   return skipNodeClass ?\n     source :\n     'LatexTree.CommandToken' + (this.command ? '' : '[?]') + '{' + source + '}';\n  }\n};\nObject.defineProperties(CommandToken.prototype, { // make getters and setters enumerable\n  command: { enumerable: true },\n  name: {enumerable: true }\n});\n\n\n\n/**\n * LaTeX environment token properties\n * @interface EnvironmentTokenProperties\n * @extends TokenProperties\n * @property {!LatexStyle.Environment} environment - The LaTeX environment\n * @property\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n */\n\n\n\n/**\n * LaTeX environment token structure\n * @class\n * @extends Token\n * @property {!LatexStyle.Environment} environment - The corresponding LaTeX environment\n * @property {?CommandToken} beginCommandToken -\n *           The environment begin command token or null is there is no such a token\n * @property {?CommandToken} endCommandToken -\n *           The environment end command token or null is there is no such a token\n * @property {?EnvironmentBodyToken} bodyToken -\n *           The environment body token or null is there is no such a token\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n */\nconst EnvironmentToken = module.exports['EnvironmentToken'] = class extends Token {\n  //noinspection JSUnusedGlobalSymbols\n  /**\n   * Constructor\n   * @param {!EnvironmentTokenProperties} initialProperties the initial property values\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n   */\n  constructor(initialProperties) {\n    if (!(initialProperties instanceof Object))\n      throw new TypeError ('\"initialProperties\" isn\\'t an Object instance');\n    super(initialProperties); // the superclass constructor\n    if (!(initialProperties.environment instanceof LatexStyle.Environment))\n      throw new TypeError(\n        '\"initialProperties.environment\" isn\\'t a LatexStyle.Environment instance');\n    // store the environment\n    Object.defineProperty(this, 'environment', {\n      value: initialProperties.environment,\n      enumerable: true\n    });\n  }\n\n\n  /**\n   * Get the logical lexeme\n   * @return {(Latex.Lexeme|null)} the lexeme or null if the lexeme isn't defined\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n   */\n  get lexeme () { return this.environment.lexeme }\n\n\n  /**\n   * Get the begin command token\n   * @return {?CommandToken} the command token or null if there is no begin command\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n   */\n  get beginCommandToken () {\n    let beginCommandToken = this.childNode(0);\n    return beginCommandToken instanceof CommandToken ? beginCommandToken : null;\n  }\n\n\n  /**\n   * Get the end command token\n   * @return {?CommandToken} the command token or null if there is no end command\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n   */\n  get endCommandToken () {\n    let endCommandToken = this.childNode(2);\n    return endCommandToken instanceof CommandToken ? endCommandToken : null;\n  }\n\n\n\n  /**\n   * Get the environment body token\n   * @return {?EnvironmentBodyToken} the body or null if there is no body\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n   */\n  get bodyToken () {\n    let bodyToken = this.childNode(1);\n    return bodyToken instanceof EnvironmentBodyToken ? bodyToken : null;\n  }\n\n\n  /**\n   * Get the string representation of this node\n   * @param {boolean=false} skipNodeClass\n   *        true to not include the node class name into the output, false otherwise\n   * @return {string} the sources string\n   * @override\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n   */\n  toString(skipNodeClass) {\n    let beginCommandToken = this.beginCommandToken; // the begin command token\n    let endCommandToken = this.endCommandToken; // the end command token\n    let bodyToken = this.bodyToken; // the environment body token\n    let source = '\\\\begin{' + this.environment.name + '}';\n    source += beginCommandToken ?\n      SymbolToken.prototype.toString.call(beginCommandToken, true) :\n      '??';\n    source += bodyToken ? bodyToken.toString(true) : '??';\n    source += '\\\\end{' + this.environment.name + '}';\n    source += endCommandToken ? SymbolToken.prototype.toString.call(endCommandToken, true) : '??';\n    return skipNodeClass ? source : 'LatexTree.EnvironmentToken{' + source + '}';\n  }\n};\nObject.defineProperties(EnvironmentToken.prototype, { // make getters and setters enumerable\n  beginToken: { enumerable: true },\n  endToken: { enumerable: true }\n});\n\n\n\n/**\n * LaTeX environment body token structure\n * @class\n * @extends Token\n * @property {?LatexStyle.Environment} environment -\n *           The LaTeX environment or null if there is no parent environment\n * @property {?EnvironmentToken} environmentToken - The parent environment token\n * @property {?CommandToken} beginCommandToken -\n *           The environment begin command token or null is there is no such a token\n * @property {?CommandToken} endCommandToken -\n *           The environment end command token or null is there is no such a token\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n */\nconst EnvironmentBodyToken = module.exports['EnvironmentBodyToken'] = class extends Token {\n  //noinspection JSUnusedGlobalSymbols\n  /**\n   * Get the LaTeX environment\n   * @return {?LatexStyle.Environment} the environment or null if there is no parent environment\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n   */\n  get environment () { return this.parentNode && this.parentNode.environment }\n\n\n  //noinspection JSUnusedGlobalSymbols\n  /**\n   * Get the parent environment token\n   * @return {?EnvironmentToken} the environment or null if there is no parent environment\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n   */\n  get environmentToken () { return this.parentNode }\n\n\n  //noinspection JSUnusedGlobalSymbols\n  /**\n   * Get the environment begin command token\n   * @return {?CommandToken} the command token or null if there is no begin command\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n   */\n  get beginCommandToken () { return this.parentNode && this.parentNode.beginCommandToken }\n\n\n  //noinspection JSUnusedGlobalSymbols\n  /**\n   * Get the environment end command token\n   * @return {(CommandToken|null)} the command token or null if there is no end command\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n   */\n  get endCommandToken () { return this.parentNode && this.parentNode.endCommandToken }\n\n\n  /**\n   * Get the string representation of this node\n   * @param {boolean=false} skipNodeClass\n   *        true to not include the node class name into the output, false otherwise\n   * @return {string} the sources string\n   * @override\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n   */\n  toString(skipNodeClass) {\n    return skipNodeClass ?\n      super.toString(true) :\n      'LatexTree.EnvironmentBodyToken{' + super.toString(true) + '}';\n  }\n};\nObject.defineProperties(EnvironmentBodyToken.prototype, { // default properties\n  parentNodeClass_: { value: EnvironmentToken } // parent node must be an EnvironmentToken instance\n});\n\n\n\n/**\n * LaTeX space token properties\n * @interface SpaceTokenProperties\n * @extends TokenProperties\n * @property {number|undefined} lineBreakCount - The number of line breaks\n * @property\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n */\n\n\n\n/**\n * LaTeX space token structure\n * @class\n * @extends Token\n * @property {number} lineBreakCount - The number of line breaks\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n */\nconst SpaceToken = module.exports['SpaceToken'] = class extends Token {\n  //noinspection JSUnusedGlobalSymbols\n  /**\n   * Constructor\n   * @param {!SpaceTokenProperties} initialProperties the initial property values\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n   */\n  constructor(initialProperties) {\n    if (initialProperties === undefined)\n      return super();\n    else if (!(initialProperties instanceof Object))\n      throw new TypeError ('\"initialProperties\" isn\\'t an Object instance');\n    super(initialProperties); // the superclass constructor\n    if (initialProperties.lineBreakCount) { // if the line break number is defined\n      if (!isFinite(initialProperties.lineBreakCount) || initialProperties.lineBreakCount < 0)\n        throw new TypeError('\"initialProperties.lineBreakCount\" isn\\'t a non-negative number');\n      // store the line break number\n      Object.defineProperty(this, 'lineBreakCount', {\n        value: initialProperties.lineBreakCount,\n        enumerable: true\n      });\n    }\n  }\n\n\n  /**\n   * Get the logical lexeme\n   * @return {(Latex.Lexeme|null)} the lexeme or null if the lexeme isn't defined\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n   */\n  get lexeme () {\n    //noinspection JSUnresolvedVariable\n    return  this.lineBreakCount <= 1 ? Latex.Lexeme.SPACE : Latex.Lexeme.PARAGRAPH_SEPARATOR;\n  }\n\n\n  /**\n   * Get the string representation of this node\n   * @param {boolean=false} skipNodeClass\n   *        true to not include the node class name into the output, false otherwise\n   * @return {string} the sources string\n   * @override\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n   */\n  toString(skipNodeClass) {\n    if (skipNodeClass) { // if the node class name must be skipped\n      switch (this.lineBreakCount) {\n      case 0:\n        return ' ';\n      case 1:\n        return '\\n';\n      default:\n        return '\\n\\n';\n      }\n    } else { // if the node class name must be included\n      switch (this.lineBreakCount) {\n      case 0:\n        return 'LatexTree.SpaceToken{ }';\n      case 1:\n        return 'LatexTree.SpaceToken{\\n}';\n      default:\n        return 'LatexTree.SpaceToken{\\n\\n}';\n      }\n    }\n  }\n};\n//noinspection JSUnresolvedVariable\nObject.defineProperties(SpaceToken.prototype, { // default properties\n  lineBreakCount: { value: 0, enumerable: true } // line break number\n});\n\n\n\n/**\n * LaTeX source fragment token properties\n * @interface SourceTokenProperties\n * @extends TokenProperties\n * @property {Latex.Lexeme} lexeme - The logical lexeme\n * @property {string} source - The source fragment\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n */\n\n\n\n/**\n * LaTeX source fragment token structure\n * @class\n * @extends Token\n * @property {string} source - The source fragment\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n */\nconst SourceToken = module.exports['SourceToken'] = class extends Token {\n  //noinspection JSUnusedGlobalSymbols\n  /**\n   * Constructor\n   * @param {!SourceTokenProperties} initialProperties the initial property values\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n   */\n  constructor(initialProperties) {\n    if (!(initialProperties instanceof Object))\n      throw new TypeError ('\"initialProperties\" isn\\'t an Object instance');\n    super(initialProperties); // the superclass constructor\n    if (!Latex.Lexeme[initialProperties.lexeme])\n      throw new TypeError('\"initialProperties.lexeme\" isn\\'t known');\n    // store the lexeme\n    Object.defineProperty(this, 'lexeme', { value: initialProperties.lexeme, enumerable: true });\n    if (typeof initialProperties.source !== 'string')\n      throw new TypeError('\"initialProperties.sources\" isn\\'t a string');\n    // store the sources\n    Object.defineProperty(this, 'source', { value: initialProperties.source, enumerable: true });\n  }\n\n\n  /**\n   * Get the string representation of this node\n   * @param {boolean=false} skipNodeClass\n   *        true to not include the node class name into the output, false otherwise\n   * @return {string} the sources string\n   * @override\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n   */\n  toString(skipNodeClass) {\n    return skipNodeClass ? this.source : 'LatexTree.SourceToken[' + this.lexeme + ']{' + this.source + '}';\n  }\n};\n"]}