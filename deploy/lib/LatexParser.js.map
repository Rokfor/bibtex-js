{"version":3,"sources":["../../sources/lib/LatexParser.js"],"names":["Latex","require","LatexStyle","LatexTree","module","exports","latexStyle","TypeError","Object","defineProperty","value","enumerable","source","opt_context","context","undefined","Context","parsedTokens","parsedToken","parseToken_","push","token","parseSpaceToken_","position","length","contextBackup","copy","parseEnvironmentToken_","parseCommandToken_","parseSymbolsToken_","processParsedToken_","parameter","opt_endLabel","currentTokenBackup","currentToken","updateState","operations","spacePrefixState","ParameterToken","hasBrackets","hasSpacePrefix","charNumber","parseUntilLabel_","lexeme","parameterToken","insertChildSubtree","commentMatch","substring","match","comments","lineNumber","isSpace","nLineBreaks","parseCommentLine_","SpaceToken","lineBreakCount","startsWith","nameMatch","name","environment","environments","currentState","environmentToken","EnvironmentToken","beginCommandToken","parsePatterns_","commands","CommandToken","environmentBodyToken","EnvironmentBodyToken","endFound","endCommandToken","commandNameMatch","sourceCharacter","symbols","SymbolToken","pattern","some","parsePattern_","symbol","Command","command","patternComponents","nPatternComponents","iPatternComponent","patternComponent","parameterEndLabel","parseParameterToken_","endLabel","opt_lexeme","opt_source","State","stateStack","opt_target","target","slice","Array","newModeStates","forEach","operation","directive","Directive","BEGIN","operand","GROUP","update","END","Error","pop"],"mappings":"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","file":"LatexParser.js","sourcesContent":["/**\n * @fileoverview LaTeX parser class\n * This file is a part of TeXnous project.\n *\n * @copyright TeXnous project team (http://texnous.org) 2016\n * @license LGPL-3.0\n *\n * This library is free software; you can redistribute it and/or modify it under the terms of the\n * GNU Lesser General Public License as published by the Free Software Foundation; either version 3\n * of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License along with this library;\n * if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n * 02111-1307, USA.\n */\n\n'use strict';\n\n/**@module */\n\n\n/** @external Latex */\nconst Latex = require('./Latex'); // general LaTeX definitions\n/** @external LatexStyle */\nconst LatexStyle = require('./LatexStyle'); // LaTeX style structures\n/** @external LatexTree */\nconst LatexTree = require('./LatexTree'); // LaTeX tree structure elements\n\n\n/**\n * LaTeX parser structure\n * @class\n * @property {!LatexStyle} latexStyle - The LaTeX style description to be used for parsing\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nmodule.exports = class {\n  //noinspection JSUnusedGlobalSymbols\n  /**\n   * Constructor\n   * @param {!LatexStyle} latexStyle LaTeX style description to be used for parsing\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n   */\n  constructor(latexStyle) {\n    if (!(latexStyle instanceof LatexStyle))\n      throw new TypeError('\"latexStyle\" isn\\'t a LatexStyle instance');\n    // store the style description\n    Object.defineProperty(this, 'latexStyle', { value: latexStyle, enumerable: true });\n  }\n\n\n  //noinspection JSUnusedGlobalSymbols\n  /**\n   * Parse LaTeX sources\n   * @param {string} source the sources to parse\n   * @param {(!Context|undefined)} opt_context the parsing context\n   * @return {!Array.<!LatexTree.Token>} the list of the parsed tokens\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n   */\n  parse(source, opt_context) {\n    if (typeof source !== 'string') throw new TypeError('\"sources\" isn\\'t a string');\n    let context;\n    if (opt_context === undefined) { // if the parsing context isn't defined\n      context = new Context(source); // create the context\n    } else if (opt_context instanceof Context) { // if the parsing context is defined\n      context = opt_context;\n      context.source += source; // update the sources\n    } else { // if unexpected context type\n      throw new TypeError('\"context\" isn\\'t a LatexParser.Context instance');\n    }\n    let parsedTokens = []; // the list of the parsed tokens\n    while (true) {\n      let parsedToken = this.parseToken_(context);\n      if (parsedToken === null) break; // stop when cannot parse a token\n      parsedTokens.push(parsedToken); // store the parsed token\n    }\n    return parsedTokens;\n  }\n\n\n  /**\n   * Parse the next token\n   * @param {!Context} context the parsing context\n   * @return {?LatexTree.Token} the parsed token or null if the token cannot be parsed\n   * @private\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n   */\n  parseToken_(context) {\n    let token = this.parseSpaceToken_(context); // collect comments and try to parse a space token\n    if (!token) { // if cannot parse a space token\n      if (context.position >= context.source.length) return null;\n      let contextBackup = context.copy(); // backup the current context\n      if (!(token = this.parseEnvironmentToken_(context))) { // if cannot parse an environment token\n        contextBackup.copy(context); // restore the context\n        if (!(token = this.parseCommandToken_(context))) { // if cannot parse a command token\n          contextBackup.copy(context); // restore the context\n          if (!(token = this.parseSymbolsToken_(context))) { // if cannot parse a symbol token\n            return null; // no token can be parsed\n          }\n        }\n      }\n    }\n    //noinspection JSCheckFunctionSignatures\n    this.processParsedToken_(context, token);\n    //noinspection JSValidateTypes\n    return token; // return the parsed token\n  }\n\n\n  /**\n   * Parse a parameter token\n   * @param {!Context} context the parsing context\n   * @param {!Array.<!LatexStyle.Parameter>} parameter the symbol or command parameter description\n   * @param {string=} opt_endLabel\n   *        the parameter end label or undefined if there should be a single token\n   * @return {?LatexTree.ParameterToken} the parsed parameter token or null if cannot parse\n   * @private\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n   */\n  parseParameterToken_(context, parameter, opt_endLabel) {\n    let currentTokenBackup = context.currentToken; // store the current token\n    //noinspection JSUnresolvedFunction,JSUnresolvedVariable\n    context.updateState(parameter.operations); // update the LaTeX state\n    if (opt_endLabel === undefined) { // if the parameter must be parsed as a single token\n      // has the param space prefix or not\n      let spacePrefixState = this.parseSpaceToken_(context) !== null;\n      if (context.source[context.position] === '{') { // if the parameter is bounded by brackets\n        // create the parameter token\n        context.currentToken =\n          new LatexTree.ParameterToken({ hasBrackets: true, hasSpacePrefix: spacePrefixState});\n        ++context.position; // go to the sources next char\n        ++context.charNumber; // go to the current line next char\n        // exit if cannot parse until the closing bracket\n        //noinspection JSUnresolvedVariable\n        if (!this.parseUntilLabel_(context, '}', parameter.lexeme)) return null;\n        ++context.position; // skip the bracket in the sources\n        ++context.charNumber; // skip the bracket in the current line\n      } else { // if the parameter is't bounded by brackets\n        // create the parameter token\n        context.currentToken =\n          new LatexTree.ParameterToken({ hasBrackets: false, hasSpacePrefix: spacePrefixState});\n        // exit if cannot parse a parameter token\n        if (this.parseToken_(context) === null) return null;\n      }\n    } else { // if the parameter must be parsed until the end label\n      // create the parameter token\n      context.currentToken =\n        new LatexTree.ParameterToken({ hasBrackets: false, hasSpacePrefix: false});\n      //noinspection JSUnresolvedVariable\n      // return if cannot parse\n      if (!this.parseUntilLabel_(context, opt_endLabel, parameter.lexeme)) return null;\n    }\n    let parameterToken = context.currentToken; // the parsed parameter token\n    context.currentToken = currentTokenBackup; // restore the current token\n    //noinspection JSCheckFunctionSignatures\n    this.processParsedToken_(context, parameterToken);\n    //noinspection JSValidateTypes\n    return parameterToken;\n  }\n\n\n  /**\n   * Fill the parsed token position, comments and parent\n   * @param {!Context} context the parsing context\n   * @param {!LatexTree.Token} token the token to process\n   * @private\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n   */\n  processParsedToken_(context, token) {\n    // TODO process comments and position\n    if (context.currentToken) { // if there is a current token\n      //noinspection JSUnresolvedFunction\n      context.currentToken.insertChildSubtree(token); // store this token as a child of the current\n    }\n  }\n\n\n  /**\n   * Parse a comment line\n   * @param {!Context} context the parsing context\n   * @return {boolean} true if there was a comment line, false otherwise\n   * @private\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n   */\n  parseCommentLine_(context) {\n    // try to find a comment int the sources tail\n    let commentMatch = context.source.substring(context.position).match(/^%([^\\n]*)(\\n[ \\t]*)?/);\n    if (commentMatch === null) return false; // return if there is no comment at this position\n    context.comments.push(commentMatch[1]); // store the comment string\n    context.position += commentMatch[0].length; // position just after the comment\n    if (commentMatch[2] === undefined) { // if there were no line breaks\n      context.charNumber += commentMatch[0].length; // go to the last char\n    } else { // if there was a line break\n      ++context.lineNumber; // one more line\n      context.charNumber = commentMatch[2].length - 1; // skip all the space chars in the new line\n    }\n    return true;\n  }\n\n\n  /**\n   * Parse space for a token (space or paragraph separator)\n   * @param {!Context} context the parsing context\n   * @return {?LatexTree.SpaceToken} the parsed token or null if cannot parse a space token\n   * @private\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n   */\n  parseSpaceToken_(context) {\n    let isSpace = false; // true is the sources fragment is a space token, false otherwise\n    let nLineBreaks = 0; // number of parsed line breaks\n    while (context.position < context.source.length) { // while there is something to parse\n      // go to the next iteration if there was a comment\n      if (this.parseCommentLine_(context)) continue;\n      switch (context.source[context.position]) { // depend on the sources current character\n        case ' ': case '\\t': // if a space or a tabular\n          isSpace = true; // and one more parsed char\n          ++context.position; // go to the next sources char\n          ++context.charNumber; // the next char of the sources line\n          continue;\n        case '\\n': // if a line break\n          isSpace = true; // and one more parsed char\n          ++nLineBreaks; // one more parsed line\n          ++context.position; // go to the next sources char\n          ++context.lineNumber; // the next sources line\n          context.charNumber = 0; // the first char of the line\n          continue; // go to the next iteration\n      }\n      break; // stop if not a space char\n    }\n    // create a space token if needed\n    return isSpace ? new LatexTree.SpaceToken({ lineBreakCount: nLineBreaks }) : null;\n  }\n\n\n  /**\n   * Parse an environment token\n   * @param {!Context} context the parsing context\n   * @return {?LatexTree.EnvironmentToken} the parsed token or null if cannot parse\n   * @private\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n   */\n  parseEnvironmentToken_(context) {\n    if (!context.source.startsWith('\\\\begin', context.position)) return null;\n    context.position += 6; // just after \"\\begin\"\n    this.parseSpaceToken_(context); // skip spaces\n    // try to obtain the environment name\n    let nameMatch = context.source.substring(context.position).match(/^{([\\w@]+\\*?)}/);\n    if (nameMatch === null) return null; // exit if cannot bet the environment name\n    let name = nameMatch[1]; // the environment name\n    context.position += nameMatch[0].length; // skip the environment name in the sources\n    context.charNumber += nameMatch[0].length; // skip the environment name in the current line\n    let currentTokenBackup = context.currentToken; // store the current token\n    // try to get the corresponding environment\n    let environment = this.latexStyle.environments(context.currentState, name)[0];\n    let environmentToken = context.currentToken = environment ? // the environment token\n      new LatexTree.EnvironmentToken({ environment: environment }) :\n      new LatexTree.EnvironmentToken({ name: name });\n    // TODO unknown environment notification\n    // try to parse the environment begin command\n    let beginCommandToken =\n      this.parsePatterns_(context, this.latexStyle.commands(context.currentState, name));\n    if (beginCommandToken === null) { // if cannot parse a command\n      // TODO notification about the unrecognized command\n      // generate unrecognized command token\n      beginCommandToken = new LatexTree.CommandToken({ name: name });\n    }\n    //noinspection JSCheckFunctionSignatures\n    this.processParsedToken_(context, beginCommandToken);\n    let environmentBodyToken = context.currentToken = new LatexTree.EnvironmentBodyToken();\n    let endFound = this.parseUntilLabel_(context, '\\\\end{' + name + '}'); // try to get to the end\n    context.currentToken = environmentToken;\n    this.processParsedToken_(context, environmentBodyToken); // process the body token\n    let endCommandToken = null; // the environment end command token\n    if (endFound) { // if the environment end was reached\n      context.position += name.length + 6; // skip the environment name in the sources\n      context.charNumber += name.length + 6; // skip the environment name in the current line\n      endCommandToken =\n        this.parsePatterns_(context, this.latexStyle.commands(context.currentState, 'end' + name));\n    } else { // if cannot find the end of the environment\n      // TODO no environment end notification\n    }\n    if (endCommandToken === null) { // if cannot parse a command\n      // TODO notification about the unrecognized command\n      // generate unrecognized command token\n      endCommandToken = new LatexTree.CommandToken({ name: 'end' + name });\n    }\n    this.processParsedToken_(context, endCommandToken); // process the end command token\n    context.currentToken = currentTokenBackup; // restore the current token\n    return environmentToken;\n  }\n\n\n  /**\n   * Parse a command token\n   * @param {!Context} context the parsing context\n   * @return {?LatexTree.CommandToken} the parsed token or null if cannot parse\n   * @private\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n   */\n  parseCommandToken_(context) {\n    // try to find a command name\n    var commandNameMatch = context.source.substring(context.position).match(/^\\\\([\\w@]+\\*?)/);\n    if (commandNameMatch === null) return null; // exit if cannot find a command name\n    context.position += commandNameMatch[0].length; // set position just after the command name\n    context.charNumber += commandNameMatch[0].length; // skip all the command name chars\n    // try to parse a command token\n    let token = this.parsePatterns_(context, this.latexStyle.commands(context.currentState,\n      commandNameMatch[1]));\n    if (token === null) { // if cannot parse a command token\n      // TODO notification about the unrecognized command\n      // generate unrecognized command token\n      token = new LatexTree.CommandToken({ name: commandNameMatch[1] });\n    }\n    //noinspection JSValidateTypes\n    return token;\n  }\n\n\n  /**\n   * Parse symbols for a token\n   * @param {!Context} context the parsing context\n   * @return {?LatexTree.Token} the parsed token or null if cannot parse\n   * @private\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n   */\n  parseSymbolsToken_(context) {\n    // get the available symbols\n    let sourceCharacter = context.source[context.position]; // the current sources character\n    // get the symbols started with the current sources character\n    //noinspection JSValidateTypes\n    let token =\n      this.parsePatterns_(context, this.latexStyle.symbols(context.currentState, sourceCharacter));\n    if (token === null) { // if cannot parse a symbol token\n      // TODO notification about the unrecognized symbol\n      ++context.position; // go to the next sources character\n      // go to the next line character (the line is the same, \\n was parsed for a space token)\n      ++context.charNumber;\n      // generate unrecognized symbol token\n      token = new LatexTree.SymbolToken({ pattern: sourceCharacter });\n    } else { // if the token was parsed\n      // TODO parse words and numbers\n    }\n    return token;\n  }\n\n\n  /**\n   * Try to parse a symbol pattern\n   * @param {!Context} context the parsing context// generate unrecognized symbol token\n   * @param {!Array.<!LatexStyle.Symbol>} symbols\n   *        the symbol or command descriptions in the priority descending order\n   * @return {?LatexTree.Token} the parsed symbol or command token or null if cannot parse\n   * @private\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n   */\n  parsePatterns_(context, symbols) {\n    let contextBackup = context.copy(); // backup the current context\n    let token = null; // the parsed token\n    symbols.some(symbol => { // for all the symbols until the parsing success\n      // stop if the token was parsed\n      if (token = this.parsePattern_(context, symbol)) return true;\n      contextBackup.copy(context); // restore the context\n      return false; // go to the next symbol\n    });\n    return token;\n  }\n\n  \n  /**\n   * Try to parse a symbol pattern\n   * @param {!Context} context the parsing context\n   * @param {!Array.<!LatexStyle.Symbol>} symbol the symbol or command description\n   * @return {?LatexTree.Token} the parsed symbol or command token or null if cannot parse\n   * @private\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n   */\n  parsePattern_(context, symbol) {\n    let currentTokenBackup = context.currentToken; // store the current token\n    // if a command description is given\n    context.currentToken = symbol instanceof LatexStyle.Command ?\n      new LatexTree.CommandToken({ command: symbol }) : // generate a command token\n      new LatexTree.SymbolToken({ symbol: symbol }); // generate a symbol token\n    //noinspection JSUnresolvedVariable\n    let patternComponents = symbol.patternComponents; // the symbol pattern components\n    let nPatternComponents = patternComponents.length; // the pattern componen number\n    let iPatternComponent = 0; // the pattern component iterator\n    // for all the pattern components\n    for ( ; iPatternComponent < nPatternComponents; ++iPatternComponent) {\n      let patternComponent = patternComponents[iPatternComponent]; // the pattern component\n      switch (typeof patternComponent) {\n      case 'number':\n      { // if a parameter is expected\n        //noinspection JSUnresolvedFunction\n        let parameter = symbol.parameter(patternComponent); // the parameter description\n        // try to get the end label for the parameter\n        let parameterEndLabel = patternComponents[iPatternComponent + 1];\n        if (typeof parameterEndLabel === 'string') { // if there is a end label\n          // if can parse the parameter token\n          if (this.parseParameterToken_(context, parameter, parameterEndLabel)) {\n            // exit if there is no the end label at the positions\n            if (!context.source.startsWith(parameterEndLabel, context.position)) return null;\n            context.position += parameterEndLabel.length; // skip the end label in the sources\n            context.charNumber += parameterEndLabel.length; // skip the end label in the line\n            ++iPatternComponent; // skip the end label in the pattern\n            continue; // go to the next pattern component\n          }\n        } else { // if there is no a end label\n          // go to the next pattern char if can parse the parameter token\n          if (this.parseParameterToken_(context, parameter)) continue;\n        }\n      }\n        break; // stop parsing if cannot parse a parameter token\n      case 'string': //\n        while (this.parseCommentLine_(context)) { } // skip all the comments\n        // if the sources fragment is equal the pattern component\n        if (context.source.startsWith(patternComponent, context.position)) {\n          context.position += patternComponent.length; // skip the pattern component in the sources\n          context.charNumber += patternComponent.length; // skip the pattern component in the line\n          continue; // go to the next pattern component\n        }\n        break;\n      default: // if a space is expected\n        // go to the next pattern component if can parse a space\n        if (this.parseSpaceToken_(context)) continue;\n      }\n      break; // stop parsing if there was no continue call\n    }\n    // return if the pattern parsing was broken\n    if (iPatternComponent < nPatternComponents) return null;\n    let parsedToken = context.currentToken; // the parsed token to return\n    context.currentToken = currentTokenBackup; // restore the current token\n    //noinspection JSUnresolvedFunction,JSUnresolvedVariable\n    context.updateState(symbol.operations); // update the LaTeX state\n    return parsedToken;\n  }\n\n\n  /**\n   * Parse tokens until the label\n   * @param {!Context} context the parsing context\n   * @param {string} endLabel the label to parse until\n   * @param {Latex.Lexeme=} opt_lexeme the lexeme of the single token to parse\n   * @return {boolean} true if the parsing was successful, false otherwise\n   * @private\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n   */\n  parseUntilLabel_(context, endLabel, opt_lexeme) {\n    switch (opt_lexeme) {\n      // TODO parse special lexemes\n    default: {\n      // while not reached the label\n      while (!context.source.startsWith(endLabel, context.position)) {\n        if (context.position >= context.source.length) { // if there is no more sources\n          // TODO notification about unexpected sources end\n          return false;\n        }\n        this.parseToken_(context);\n      }\n      return true;\n    }}\n  }\n};\n\n\n\n/**\n * The parsing context\n * @struct\n * @property {string} source - The source to parse\n * @property {number} position - The current position in the source\n * @property {?LatexTree.Token} currentToken - The currently parsing token\n * @property {!Latex.State} currentState - The current LaTeX state\n * @property {!Array.<!Latex.State>} stateStack - The stack of LaTeX sates\n * @property {!Array.<string>} comments - The comment list for the nex token\n * @property {number} lineNumber - The current line number\n * @property {number} charNumber - The current char number in the current line\n * @property {function} copy\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n */\nconst Context = module.exports['Context'] = class {\n  //noinspection JSUnusedGlobalSymbols\n  /**\n   * Constructor\n   * @param {string=} opt_source the sources to parse (empty string by default)\n   */\n  constructor(opt_source) {\n    this.source = opt_source || ''; // store the sources\n    this.position = 0; // start from the beginning\n    this.lineNumber = 0; // start from the line 0\n    this.charNumber = 0; // start from the char 0\n    this.currentToken = null; // no tokens were parsed\n    this.currentState = new Latex.State(); // initial LaTeX state\n    this.stateStack = []; // no stored states\n    this.comments = []; // no comments for the next token\n  }\n\n\n  //noinspection JSUnusedGlobalSymbols\n  /**\n   * Copy this context\n   * @param {!Context=} opt_target the context to copy to or undefined to create a new one\n   * @return {!Context} the context copy\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n   */\n  copy(opt_target) {\n    let target = opt_target || new Context(); // the context to copy this context in\n    target.source = this.source;\n    target.position = this.position;\n    target.lineNumber = this.lineNumber;\n    target.charNumber = this.charNumber;\n    target.currentToken = this.currentToken;\n    target.currentState = this.currentState.copy();\n    target.stateStack = this.stateStack.slice();\n    target.comments = this.comments.slice();\n    return target;\n  }\n\n\n  //noinspection JSUnusedGlobalSymbols\n  /**\n   * Update the LaTeX state\n   * @param {!Array.<!Latex.Operation>} operations the LaTeX operation list\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n   */\n  updateState(operations) {\n    if (!(operations instanceof Array))\n      throw new TypeError('\"operations\" isn\\'t an Array instance');\n    let newModeStates = {}; // the modes to update\n    operations.forEach(operation => {\n      //noinspection JSUnresolvedVariable\n      switch (operation.directive) {\n      case Latex.Directive.BEGIN:\n        //noinspection JSUnresolvedVariable\n        switch (operation.operand) {\n        case Latex.GROUP:\n          this.currentState.update(newModeStates); // store the mode states\n          newModeStates = {}; // no more states to update\n          this.stateStack.push(this.currentState.copy()); // store the current state\n          break;\n        default:\n          //noinspection JSUnresolvedVariable\n          newModeStates[operation.operand] = true; // turn the state on\n        }\n        break;\n      case Latex.Directive.END:\n        //noinspection JSUnresolvedVariable\n        switch (operation.operand) {\n        case Latex.GROUP:\n          newModeStates = {}; // no need to store the states\n          if (this.stateStack.length < 1) throw new Error('state stack is empty');\n          this.currentState = this.stateStack.pop(); // restore the current state\n          break;\n        default:\n          //noinspection JSUnresolvedVariable\n          newModeStates[operation.operand] = false; // turn the state off\n        }\n        break;\n      }\n    });\n    this.currentState.update(newModeStates); // store the mode states\n  }\n};\n"]}