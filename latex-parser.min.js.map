{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///latex-parser.min.js","webpack:///webpack/bootstrap c36f79df34992f3b485d","webpack:///./sources/lib/Utils.ts","webpack:///./sources/lib/Latex.ts","webpack:///./sources/lib/LatexStyle.ts","webpack:///./sources/lib/LatexTree.ts","webpack:///./sources/lib/SyntaxTree.ts","webpack:///./sources/lib/LatexParser.ts","webpack:///./sources/main.ts"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","updateProperties","target","values","opt_keys","opt_attributes","arguments","length","undefined","writable","TypeError","key","create","Array","forEach","targetKey","_key","testProperties","opt_skipUndefined","every","_key2","isNumber","x","isString","mustNotBeUndefined","Error","_classCallCheck","instance","Constructor","isMode","modes","mustBeMode","isOperationProperties","mustBeOperationProperties","_createClass","defineProperties","props","descriptor","protoProps","staticProps","Lexeme","BINARY_OPERATOR","BRACKETS","CELL_SEPARATOR","CHAR","DIGIT","DIRECTIVE","DISPLAY_EQUATION","FILE_PATH","FLOATING_BOX","HORIZONTAL_SKIP","INLINE_EQUATION","LABEL","LENGTH","LETTER","LINE_BREAK","LIST_ITEM","LIST","NUMBER","PARAGRAPH_SEPARATOR","PICTURE","POST_OPERATOR","PRE_OPERATOR","RAW","SPACE","SUBSCRIPT","SUPERSCRIPT","TABLE","TABULAR_PARAMETERS","TAG","UNKNOWN","VERTICAL_SKIP","WORD","WRAPPER","MATH","TEXT","VERTICAL","State","opt_initialModeStates","modeStates_","update","modeStates","modeKey","mode","Directive","BEGIN","END","GROUP","Operation","opt_initialProperties","directive","operand","other","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","constructor","setPrototypeOf","__proto__","isArray","mustBeArray","isParameterProperties","ignored","mustBeParameterProperties","isCommand","Command","mustBeCommand","isEnvironment","Environment","_typeof","Symbol","iterator","obj","_get","receiver","Function","desc","getOwnPropertyDescriptor","parent","getPrototypeOf","Utils_1","Latex_1","LatexStyle","symbols_","commands_","environments_","packageName","stylePackage","symbols","iSymbol","symbol","_Symbol","pattern","symbolPatternFirstChar","push","commands","iCommand","command","environments","iEnvironment","environment","envName","storedEnv","filteredSymbols","filter","styleItem","commandName","filteredCommands","environmentName","filteredEnvironments","state","patternFirstChar","SyntaxError","test","env","default","Item","lexeme","Parameter","_Item","_this","operations","map","operation","operations_","iOperation","equals","slice","_Item2","_this2","parameters","parameters_","parameter","patternComponents","match","patternComponents_","patternPart","parameterIndex","Number","substring","html","iParameter","patternComponent","join","_Symbol2","_this3","_Item3","_this4","isCommandToken","CommandToken","mustBeEnvironmentToken","isEnvironmentToken","EnvironmentToken","getBeginCommandToken","beginCommandToken","getEndCommandToken","endCommandToken","getEnvironment","LatexStyle_1","SyntaxTree_1","default_1","_SyntaxTree_1$SyntaxT","rootToken","source","Token","SyntaxTree","_SyntaxTree_1$Node","superInitialProperties","parentNode","parentToken","childNodes","childTokens","Node","parentNodeClass_","SymbolToken","_Token","initialProperties","skipNodeClass","nPatternChars","iPatternChar","patternChar","parameterToken","childNode","toString","ParameterToken","_Token2","hasBrackets","hasSpacePrefix","symbolToken","childIndex","_SymbolToken","_this5","_Token3","_this6","bodyToken","EnvironmentBodyToken","beginToken","endToken","_Token4","apply","SpaceToken","_Token5","_this8","lineBreakCount","isFinite","SourceToken","_Token6","_this9","_toConsumableArray","arr","arr2","from","rootNode","tree","insertChildSubtree","optParentNode","node","childNodes_","indexOf","childNodesToCover","nodeChildNodes","splice","subtreeSize","nodeChildNode","nodeSubtreeSize","nodeOrNodeIndex","_childNodes_","nodeChildIndex","concat","parseCommentLine_","context","commentMatch","position","comments","lineNumber","charNumber","processParsedToken_","token","currentToken","parseSpaceToken_","isSpace","nLineBreaks","LatexTree_1","LatexParser","latexStyle","opt_context","Context","parsedTokens","parsedToken","parseToken_","contextBackup","copy","parseEnvironmentToken_","parseCommandToken_","parseSymbolsToken_","opt_endLabel","currentTokenBackup","updateState","spacePrefixState","parseUntilLabel_","startsWith","nameMatch","currentState","environmentToken","parsePatterns_","environmentBodyToken","endFound","cmdMatch","sourceCharacter","some","parsePattern_","nPatternComponents","iPatternComponent","parameterEndLabel","parseParameterToken_","endLabel","opt_lexeme","opt_source","stateStack","opt_target","newModeStates","pop","__export"],"mappings":"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","file":"latex-parser.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"latex-parser\"] = factory();\n\telse\n\t\troot[\"latex-parser\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"latex-parser\"] = factory();\n\telse\n\t\troot[\"latex-parser\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 6);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction updateProperties(target, values, opt_keys) {\n    var opt_attributes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : { writable: true, enumerable: true, configurable: true };\n\n    if (!(target instanceof Object)) throw new TypeError('\"target\" isn\\'t an Object instance');\n    if (values === undefined) return;\n    if (!(values instanceof Object)) throw new TypeError('\"properties\" isn\\'t an Object instance');\n    if (opt_attributes === undefined) {\n        opt_attributes = { writable: true, enumerable: true, configurable: true };\n    } else if (!(opt_attributes instanceof Object)) {\n        throw new TypeError('\"attributes\" isn\\'t an Object instance');\n    }\n    if (opt_keys === undefined) {\n        for (var key in values) {\n            if (values[key] !== undefined) {\n                Object.defineProperty(target, key, Object.create(opt_attributes, { value: { value: values[key] } }));\n            }\n        }\n    } else if (opt_keys instanceof Array) {\n        opt_keys.forEach(function (key) {\n            if (values[key] !== undefined) {\n                Object.defineProperty(target, key, Object.create(opt_attributes, { value: { value: values[key] } }));\n            }\n        });\n    } else if (opt_keys instanceof Object) {\n        for (var targetKey in opt_keys) {\n            var _key = opt_keys[targetKey];\n            if (values[_key] !== undefined) Object.defineProperty(target, targetKey, Object.create(opt_attributes, { value: { value: values[_key] } }));\n        }\n    } else {\n        throw new TypeError('\"keys\" isn\\'t an Object instance');\n    }\n}\nexports.updateProperties = updateProperties;\n;\nfunction testProperties(target, values, opt_keys) {\n    var opt_skipUndefined = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n    if (!(target instanceof Object)) throw new TypeError('\"target\" isn\\'t an Object instance');\n    if (values === undefined) return true;\n    if (!(values instanceof Object)) throw new TypeError('\"properties\" isn\\'t an Object instance');\n    if (opt_skipUndefined === undefined) opt_skipUndefined = true;\n    if (opt_keys === undefined) {\n        for (var key in values) {\n            if (target[key] !== values[key] && !(values[key] === undefined && opt_skipUndefined)) return false;\n        }\n    } else if (opt_keys instanceof Array) {\n        return opt_keys.every(function (key) {\n            return target[key] === values[key] || values[key] === undefined && opt_skipUndefined;\n        });\n    } else if (opt_keys instanceof Object) {\n        for (var targetKey in opt_keys) {\n            var _key2 = opt_keys[targetKey];\n            if (target[targetKey] !== values[_key2] && !(values[_key2] === undefined && opt_skipUndefined)) return false;\n        }\n    } else {\n        throw new TypeError('\"keys\" isn\\'t an Object instance');\n    }\n    return true;\n}\nexports.testProperties = testProperties;\n;\nfunction isNumber(x) {\n    return typeof x === \"number\";\n}\nexports.isNumber = isNumber;\nfunction isString(x) {\n    return typeof x === \"string\";\n}\nexports.isString = isString;\nfunction mustNotBeUndefined(x) {\n    if (!x) throw new Error();\n    return x;\n}\nexports.mustNotBeUndefined = mustNotBeUndefined;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Lexeme = {\n    BINARY_OPERATOR: 'BINARY_OPERATOR',\n    BRACKETS: 'BRACKETS',\n    CELL_SEPARATOR: 'CELL_SEPARATOR',\n    CHAR: 'CHAR',\n    DIGIT: 'DIGIT',\n    DIRECTIVE: 'DIRECTIVE',\n    DISPLAY_EQUATION: 'DISPLAY_EQUATION',\n    FILE_PATH: 'FILE_PATH',\n    FLOATING_BOX: 'FLOATING_BOX',\n    HORIZONTAL_SKIP: 'HORIZONTAL_SKIP',\n    INLINE_EQUATION: 'INLINE_EQUATION',\n    LABEL: 'LABEL',\n    LENGTH: 'LENGTH',\n    LETTER: 'LETTER',\n    LINE_BREAK: 'LINE_BREAK',\n    LIST_ITEM: 'LIST_ITEM',\n    LIST: 'LIST',\n    NUMBER: 'NUMBER',\n    PARAGRAPH_SEPARATOR: 'PARAGRAPH_SEPARATOR',\n    PICTURE: 'PICTURE',\n    POST_OPERATOR: 'POST_OPERATOR',\n    PRE_OPERATOR: 'PRE_OPERATOR',\n    RAW: 'RAW',\n    SPACE: 'SPACE',\n    SUBSCRIPT: 'SUBSCRIPT',\n    SUPERSCRIPT: 'SUPERSCRIPT',\n    TABLE: 'TABLE',\n    TABULAR_PARAMETERS: 'TABULAR_PARAMETERS',\n    TAG: 'TAG',\n    UNKNOWN: 'UNKNOWN',\n    VERTICAL_SKIP: 'VERTICAL_SKIP',\n    WORD: 'WORD',\n    WRAPPER: 'WRAPPER'\n};\nexports.modes = {\n    LIST: 'LIST',\n    MATH: 'MATH',\n    PICTURE: 'PICTURE',\n    TABLE: 'TABLE',\n    TEXT: 'TEXT',\n    VERTICAL: 'VERTICAL'\n};\nfunction isMode(x) {\n    return exports.modes.hasOwnProperty(x);\n}\nexports.isMode = isMode;\nfunction mustBeMode(x) {\n    if (!isMode(x)) throw new Error();\n    return x;\n}\nexports.mustBeMode = mustBeMode;\n\nvar State = function () {\n    function State() {\n        var opt_initialModeStates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, State);\n\n        Object.defineProperty(this, 'modeStates_', { value: {}, enumerable: false });\n        this.modeStates_[exports.modes.LIST] = false;\n        this.modeStates_[exports.modes.MATH] = false;\n        this.modeStates_[exports.modes.PICTURE] = false;\n        this.modeStates_[exports.modes.TABLE] = false;\n        this.modeStates_[exports.modes.TEXT] = true;\n        this.modeStates_[exports.modes.VERTICAL] = false;\n        if (opt_initialModeStates !== undefined) this.update(opt_initialModeStates);\n    }\n\n    _createClass(State, [{\n        key: 'copy',\n        value: function copy() {\n            return new State(this.modeStates_);\n        }\n    }, {\n        key: 'update',\n        value: function update(modeStates) {\n            for (var modeKey in modeStates) {\n                var mode = exports.modes[mustBeMode(modeKey)];\n                if (mode === undefined) throw new TypeError('\"modeStates[' + modeKey + ']\" isn\\'t a Latex.Mode option');\n                this.modeStates_[mode] = modeStates[modeKey];\n            }\n        }\n    }, {\n        key: 'test',\n        value: function test(modeStates) {\n            for (var modeKey in modeStates) {\n                var mode = exports.modes[mustBeMode(modeKey)];\n                if (mode === undefined) throw new TypeError('\"modeStates[' + modeKey + ']\" isn\\'t a Latex.Mode option');\n                if (this.modeStates_[mode] !== modeStates[modeKey]) return false;\n            }\n            return true;\n        }\n    }]);\n\n    return State;\n}();\n\nexports.State = State;\n;\nexports.Directive = {\n    BEGIN: 'BEGIN',\n    END: 'END'\n};\nexports.GROUP = 'GROUP';\nfunction isOperationProperties(x) {\n    return x && x.hasOwnProperty(\"directive\") && x.hasOwnProperty(\"operand\");\n}\nexports.isOperationProperties = isOperationProperties;\nfunction mustBeOperationProperties(x) {\n    if (!isOperationProperties(x)) throw new Error();\n    return x;\n}\nexports.mustBeOperationProperties = mustBeOperationProperties;\n\nvar Operation = function () {\n    function Operation(opt_initialProperties) {\n        _classCallCheck(this, Operation);\n\n        if (opt_initialProperties === undefined) return;\n        if (!(opt_initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n        var directive = exports.Directive[opt_initialProperties.directive];\n        if (!directive) throw new TypeError('\"initialProperties.directive\" isn\\'t an Latex.Directive option');\n        Object.defineProperty(this, 'directive', { value: directive, enumerable: true });\n        switch (opt_initialProperties.operand) {\n            case exports.GROUP:\n                Object.defineProperty(this, 'operand', { value: exports.GROUP, enumerable: true });\n                break;\n            default:\n                var mode = exports.modes[opt_initialProperties.operand];\n                if (!mode) throw new TypeError('\"initialProperties.operand\" isn\\'t an Latex.Mode option');\n                Object.defineProperty(this, 'operand', { value: mode, enumerable: true });\n        }\n    }\n\n    _createClass(Operation, [{\n        key: 'equals',\n        value: function equals(other) {\n            if (!(other instanceof Operation)) return false;\n            return this.directive === other.directive && this.operand === other.operand;\n        }\n    }]);\n\n    return Operation;\n}();\n\nexports.Operation = Operation;\n;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Utils_1 = __webpack_require__(0);\nvar Latex_1 = __webpack_require__(1);\nfunction isArray(x) {\n    return x.constructor === Array;\n}\nfunction mustBeArray(x) {\n    if (!isArray(x)) throw new Error();\n    return x;\n}\n\nvar LatexStyle = function () {\n    function LatexStyle() {\n        _classCallCheck(this, LatexStyle);\n\n        this.symbols_ = {};\n        this.commands_ = {};\n        this.environments_ = {};\n    }\n\n    _createClass(LatexStyle, [{\n        key: \"loadPackage\",\n        value: function loadPackage(packageName, stylePackage) {\n            if (stylePackage.symbols !== undefined) {\n                if (!(stylePackage.symbols instanceof Array)) throw new TypeError('\"stylePackage.symbols\" isn\\'t an Array');\n                for (var iSymbol = stylePackage.symbols.length - 1; iSymbol >= 0; --iSymbol) {\n                    var symbol = new _Symbol(stylePackage.symbols[iSymbol]);\n                    if (symbol.pattern) {\n                        var symbolPatternFirstChar = symbol.pattern[0];\n                        if (!this.symbols_.hasOwnProperty(symbolPatternFirstChar)) this.symbols_[symbolPatternFirstChar] = [];\n                        var symbols = this.symbols_[symbolPatternFirstChar];\n                        symbols.push({ symbol: symbol, packageName: packageName });\n                    }\n                }\n            }\n            if (stylePackage.commands !== undefined) {\n                if (!(stylePackage.commands instanceof Array)) throw new TypeError('\"stylePackage.commands\" isn\\'t an Array');\n                for (var iCommand = stylePackage.commands.length - 1; iCommand >= 0; --iCommand) {\n                    var command = new Command(stylePackage.commands[iCommand]);\n                    if (command.name) {\n                        (this.commands_[command.name] || (this.commands_[command.name] = [])).push({ command: command, packageName: packageName });\n                    }\n                }\n            }\n            if (stylePackage.environments !== undefined) {\n                if (!(stylePackage.environments instanceof Array)) throw new TypeError(\"\\\"stylePackage.environments\\\" isn't an Array\");\n                for (var iEnvironment = stylePackage.environments.length - 1; iEnvironment >= 0; --iEnvironment) {\n                    var environment = new Environment(stylePackage.environments[iEnvironment]);\n                    var envName = environment.name;\n                    if (envName) {\n                        var storedEnv = this.environments_[envName];\n                        if (storedEnv === undefined) {\n                            storedEnv = [];\n                            this.environments_[envName] = storedEnv;\n                        }\n                        storedEnv.push({ environment: environment, packageName: packageName });\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"unloadPackage\",\n        value: function unloadPackage(packageName) {\n            for (var symbolPatternFirstChar in this.symbols_) {\n                if (this.symbols_.hasOwnProperty(symbolPatternFirstChar)) {\n                    var filteredSymbols = mustBeArray(this.symbols_[symbolPatternFirstChar]).filter(function (styleItem) {\n                        return styleItem.packageName !== packageName;\n                    });\n                    if (filteredSymbols.length) {\n                        this.symbols_[symbolPatternFirstChar] = filteredSymbols;\n                    } else {\n                        delete this.symbols_[symbolPatternFirstChar];\n                    }\n                }\n            }for (var commandName in this.commands_) {\n                if (this.commands_.hasOwnProperty(commandName)) {\n                    var filteredCommands = mustBeArray(this.commands_[commandName]).filter(function (styleItem) {\n                        return styleItem.packageName !== packageName;\n                    });\n                    if (filteredCommands.length) {\n                        this.commands_[commandName] = filteredCommands;\n                    } else {\n                        delete this.commands_[commandName];\n                    }\n                }\n            }for (var environmentName in this.environments_) {\n                if (this.environments_.hasOwnProperty(environmentName)) {\n                    var filteredEnvironments = mustBeArray(this.environments_[environmentName]).filter(function (styleItem) {\n                        return styleItem.packageName !== packageName;\n                    });\n                    if (filteredEnvironments.length) {\n                        this.environments_[environmentName] = filteredEnvironments;\n                    } else {\n                        delete this.environments_[environmentName];\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"symbols\",\n        value: function symbols(state, patternFirstChar) {\n            if (!(state instanceof Latex_1.State)) throw new SyntaxError('\"state\" isn\\'t a State instance');\n            var symbols = this.symbols_[patternFirstChar];\n            if (symbols === undefined) return [];\n            var filteredSymbols = [];\n            for (var iSymbol = mustBeArray(symbols).length - 1; iSymbol >= 0; --iSymbol) {\n                var symbol = symbols[iSymbol].symbol;\n                if (state.test(symbol.modes)) filteredSymbols.push(symbol);\n            }\n            return filteredSymbols;\n        }\n    }, {\n        key: \"commands\",\n        value: function commands(state, name) {\n            if (!(state instanceof Latex_1.State)) throw new SyntaxError('\"state\" isn\\'t a State instance');\n            var commands = this.commands_[name];\n            if (!commands) return [];\n            var filteredCommands = [];\n            for (var iCommand = mustBeArray(commands).length - 1; iCommand >= 0; --iCommand) {\n                var command = commands[iCommand].command;\n                if (state.test(command.modes)) filteredCommands.push(command);\n            }\n            return filteredCommands;\n        }\n    }, {\n        key: \"environments\",\n        value: function environments(state, name) {\n            if (!(state instanceof Latex_1.State)) throw new SyntaxError('state isn\\'t State instance');\n            var environments = this.environments_[name];\n            if (!environments) return [];\n            return mustBeArray(environments).filter(function (env) {\n                return state.test(env.modes);\n            });\n        }\n    }]);\n\n    return LatexStyle;\n}();\n\nexports.default = LatexStyle;\n;\n\nvar Item = function () {\n    function Item() {\n        var opt_initialProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, Item);\n\n        if (opt_initialProperties === undefined) return;\n        if (!(opt_initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n        switch (opt_initialProperties.lexeme) {\n            case undefined:\n                break;\n            case null:\n                break;\n            default:\n                var lexeme = Latex_1.Lexeme[opt_initialProperties.lexeme];\n                if (lexeme === undefined) throw new TypeError('\"initialProperties.lexeme\" isn\\'t a Lexeme option');\n                Object.defineProperty(this, 'lexeme', { value: lexeme });\n        }\n        if (opt_initialProperties.modes !== undefined) {\n            if (!(opt_initialProperties.modes instanceof Object)) throw new TypeError('\"initialProperties.modes\" isn\\'t an Object instance');\n            Object.defineProperty(this, 'modes', { value: {} });\n            for (var modeKey in opt_initialProperties.modes) {\n                var mode = Latex_1.mustBeMode(modeKey);\n                if (mode === undefined) throw new TypeError('\"initialProperties.modes[' + modeKey + ']\" isn\\'t a Mode option');\n                Object.defineProperty(this.modes, mode, {\n                    value: opt_initialProperties.modes[modeKey],\n                    enumerable: true\n                });\n            }\n        }\n    }\n\n    _createClass(Item, [{\n        key: \"equals\",\n        value: function equals(other) {\n            if (!(other instanceof Item)) return false;\n            return this.lexeme === other.lexeme && Utils_1.testProperties(this.modes, other.modes, Latex_1.modes, false);\n        }\n    }]);\n\n    return Item;\n}();\n\nexports.Item = Item;\n;\nObject.defineProperties(Item.prototype, {\n    lexeme: { value: undefined, enumerable: true },\n    modes: { value: {}, enumerable: true }\n});\nfunction isParameterProperties(ignored) {\n    return true;\n}\nexports.isParameterProperties = isParameterProperties;\nfunction mustBeParameterProperties(x) {\n    if (!isParameterProperties) throw new Error();\n    return x;\n}\nexports.mustBeParameterProperties = mustBeParameterProperties;\n\nvar Parameter = function (_Item) {\n    _inherits(Parameter, _Item);\n\n    function Parameter() {\n        var opt_initialProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, Parameter);\n\n        var _this = _possibleConstructorReturn(this, (Parameter.__proto__ || Object.getPrototypeOf(Parameter)).call(this, opt_initialProperties));\n\n        if (opt_initialProperties === undefined) return _possibleConstructorReturn(_this);\n        if (opt_initialProperties.operations !== undefined) {\n            if (!(opt_initialProperties.operations instanceof Array)) throw new TypeError('\"initialProperties.operations\" isn\\'t an Array instance');\n            Object.defineProperty(_this, 'operations_', {\n                value: opt_initialProperties.operations.map(function (operation) {\n                    return new Latex_1.Operation(operation);\n                })\n            });\n        }\n        return _this;\n    }\n\n    _createClass(Parameter, [{\n        key: \"equals\",\n        value: function equals(other) {\n            if (!(other instanceof Parameter)) return false;\n            if (!_get(Parameter.prototype.__proto__ || Object.getPrototypeOf(Parameter.prototype), \"equals\", this).call(this, other)) return false;\n            if (this.operations_.length !== other.operations_.length) return false;\n            return this.operations_.every(function (operation, iOperation) {\n                return operation.equals(other.operations_[iOperation]);\n            });\n        }\n    }, {\n        key: \"operations\",\n        get: function get() {\n            return this.operations_.slice();\n        }\n    }]);\n\n    return Parameter;\n}(Item);\n\nexports.Parameter = Parameter;\n;\nObject.defineProperties(Parameter.prototype, {\n    operations: { enumerable: true }\n});\nObject.defineProperties(Parameter.prototype, {\n    operations_: { value: [], enumerable: false }\n});\n\nvar _Symbol = function (_Item2) {\n    _inherits(_Symbol, _Item2);\n\n    function _Symbol() {\n        var opt_initialProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, _Symbol);\n\n        var _this2 = _possibleConstructorReturn(this, (_Symbol.__proto__ || Object.getPrototypeOf(_Symbol)).call(this, opt_initialProperties));\n\n        if (opt_initialProperties === undefined) return _possibleConstructorReturn(_this2);\n        if (opt_initialProperties.operations !== undefined) {\n            if (!(opt_initialProperties.operations instanceof Array)) throw new TypeError('\"initialProperties.operations\" isn\\'t an Array instance');\n            Object.defineProperty(_this2, 'operations_', {\n                value: opt_initialProperties.operations.map(function (operation) {\n                    return new Latex_1.Operation(Latex_1.mustBeOperationProperties(operation));\n                })\n            });\n        }\n        if (opt_initialProperties.parameters !== undefined) {\n            if (!(opt_initialProperties.parameters instanceof Array)) throw new TypeError('\"initialProperties.parameters\" isn\\'t an Array instance');\n            _this2.parameters_ = opt_initialProperties.parameters.map(function (parameter) {\n                return new Parameter(mustBeParameterProperties(parameter));\n            });\n        }\n        if (opt_initialProperties.pattern !== undefined) {\n            if (typeof opt_initialProperties.pattern !== 'string') throw new TypeError('\"initialProperties.pattern\" isn\\'t a string');\n            var patternComponents = opt_initialProperties.pattern.match(/([ \\t]+|#\\d+|[^ \\t#]+)/g);\n            if (!!patternComponents) {\n                _this2.patternComponents_ = patternComponents.map(function (patternPart) {\n                    switch (patternPart[0]) {\n                        case ' ':\n                        case '\\t':\n                            return undefined;\n                        case '#':\n                            var parameterIndex = Number(patternPart.substring(1)) - 1;\n                            if (!_this2.parameters_[parameterIndex]) throw new TypeError('\"initialProperties.pattern\" contains the incorrect parameter number ' + patternPart.substring(1));\n                            return parameterIndex;\n                        default:\n                            return patternPart;\n                    }\n                });\n            }\n        }\n        if (opt_initialProperties.html !== undefined) {\n            if (typeof opt_initialProperties.html !== 'string') throw new TypeError('\"initialProperties.html\" isn\\'t a string');\n            Object.defineProperty(_this2, 'html', { value: opt_initialProperties.html, enumerable: true });\n        }\n        return _this2;\n    }\n\n    _createClass(_Symbol, [{\n        key: \"parameter\",\n        value: function parameter(parameterIndex) {\n            return this.parameters_[parameterIndex] || undefined;\n        }\n    }, {\n        key: \"equals\",\n        value: function equals(other) {\n            if (!(other instanceof _Symbol)) return false;\n            if (!_get(_Symbol.prototype.__proto__ || Object.getPrototypeOf(_Symbol.prototype), \"equals\", this).call(this, other)) return false;\n            if (this.operations_.length !== other.operations_.length) return false;\n            if (!this.operations_.every(function (operation, iOperation) {\n                return operation.equals(other.operations_[iOperation]);\n            })) return false;\n            if (this.parameters_.length !== other.parameters_.length) return false;\n            if (!this.parameters_.every(function (parameter, iParameter) {\n                return parameter.equals(other.parameters_[iParameter]);\n            })) return false;\n            return this.html === other.html;\n        }\n    }, {\n        key: \"operations\",\n        get: function get() {\n            return this.operations_.slice();\n        }\n    }, {\n        key: \"parameters\",\n        get: function get() {\n            return this.parameters_.slice();\n        }\n    }, {\n        key: \"patternComponents\",\n        get: function get() {\n            return Utils_1.mustNotBeUndefined(this.patternComponents_.slice());\n        }\n    }, {\n        key: \"pattern\",\n        get: function get() {\n            return this.patternComponents_.map(function (patternComponent) {\n                if (Utils_1.isNumber(patternComponent)) {\n                    return '#' + (patternComponent + 1);\n                }\n                switch (typeof patternComponent === \"undefined\" ? \"undefined\" : _typeof(patternComponent)) {\n                    case 'string':\n                        return patternComponent;\n                    default:\n                        return ' ';\n                }\n            }).join('');\n        }\n    }]);\n\n    return _Symbol;\n}(Item);\n\nexports.Symbol = _Symbol;\n;\nObject.defineProperties(_Symbol.prototype, {\n    operations: { enumerable: true },\n    parameters: { enumerable: true },\n    patternComponents: { enumerable: true },\n    pattern: { enumerable: true }\n});\nObject.defineProperties(_Symbol.prototype, {\n    operations_: { value: [], enumerable: false, writable: true },\n    parameters_: { value: [], enumerable: false, writable: true },\n    patternComponents_: { value: [], enumerable: false, writable: true },\n    html: { value: '', enumerable: true, writable: true }\n});\n\nvar Command = function (_Symbol2) {\n    _inherits(Command, _Symbol2);\n\n    function Command() {\n        var opt_initialProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, Command);\n\n        var _this3 = _possibleConstructorReturn(this, (Command.__proto__ || Object.getPrototypeOf(Command)).call(this, opt_initialProperties));\n\n        if (opt_initialProperties === undefined) return _possibleConstructorReturn(_this3);\n        if (opt_initialProperties.name !== undefined) {\n            if (typeof opt_initialProperties.name !== 'string') throw new TypeError('\"initialProperties.name\" isn\\'t a string');\n            Object.defineProperty(_this3, 'name', { value: opt_initialProperties.name });\n        }\n        return _this3;\n    }\n\n    _createClass(Command, [{\n        key: \"equals\",\n        value: function equals(other) {\n            if (!(other instanceof Command)) return false;\n            if (!_get(Command.prototype.__proto__ || Object.getPrototypeOf(Command.prototype), \"equals\", this).call(this, other)) return false;\n            return this.name === other.name;\n        }\n    }]);\n\n    return Command;\n}(_Symbol);\n\nexports.Command = Command;\n;\nObject.defineProperties(Command.prototype, {\n    name: { value: '', enumerable: true }\n});\nfunction isCommand(c) {\n    return c instanceof Command;\n}\nexports.isCommand = isCommand;\nfunction mustBeCommand(c) {\n    if (!isCommand(c)) throw new Error();\n    return c;\n}\nexports.mustBeCommand = mustBeCommand;\n\nvar Environment = function (_Item3) {\n    _inherits(Environment, _Item3);\n\n    function Environment() {\n        var opt_initialProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, Environment);\n\n        var _this4 = _possibleConstructorReturn(this, (Environment.__proto__ || Object.getPrototypeOf(Environment)).call(this, opt_initialProperties));\n\n        if (opt_initialProperties === undefined) return _possibleConstructorReturn(_this4);\n        if (opt_initialProperties.name !== undefined) {\n            if (typeof opt_initialProperties.name !== 'string') throw new TypeError('\"initialProperties.name\" isn\\'t a string');\n            Object.defineProperty(_this4, 'name', { value: opt_initialProperties.name });\n        }\n        return _this4;\n    }\n\n    _createClass(Environment, [{\n        key: \"equals\",\n        value: function equals(other) {\n            if (!(other instanceof Environment)) return false;\n            if (!_get(Environment.prototype.__proto__ || Object.getPrototypeOf(Environment.prototype), \"equals\", this).call(this, other)) return false;\n            return this.name === other.name;\n        }\n    }]);\n\n    return Environment;\n}(Item);\n\nexports.Environment = Environment;\n;\nObject.defineProperties(Environment.prototype, {\n    name: { value: '', enumerable: true }\n});\nfunction isEnvironment(x) {\n    return x instanceof Environment;\n}\nexports.isEnvironment = isEnvironment;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar LatexStyle_1 = __webpack_require__(2);\nvar SyntaxTree_1 = __webpack_require__(4);\nvar Latex_1 = __webpack_require__(1);\nvar Utils_1 = __webpack_require__(0);\n\nvar default_1 = function (_SyntaxTree_1$SyntaxT) {\n    _inherits(default_1, _SyntaxTree_1$SyntaxT);\n\n    function default_1(rootToken, source) {\n        _classCallCheck(this, default_1);\n\n        if (!(rootToken instanceof Token)) throw new TypeError('\"rootToken\" isn\\'t a Token instance');\n        return _possibleConstructorReturn(this, (default_1.__proto__ || Object.getPrototypeOf(default_1)).call(this, rootToken, source));\n    }\n\n    return default_1;\n}(SyntaxTree_1.SyntaxTree);\n\nexports.default = default_1;\n;\n\nvar Token = function (_SyntaxTree_1$Node) {\n    _inherits(Token, _SyntaxTree_1$Node);\n\n    function Token() {\n        var opt_initialProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, Token);\n\n        if (opt_initialProperties === undefined) {\n            var _this2 = _possibleConstructorReturn(this, (Token.__proto__ || Object.getPrototypeOf(Token)).call(this));\n        } else if (opt_initialProperties instanceof Object) {\n            var superInitialProperties = Object.create(opt_initialProperties);\n            superInitialProperties.parentNode = opt_initialProperties.parentToken;\n            superInitialProperties.childNodes = opt_initialProperties.childTokens;\n\n            var _this2 = _possibleConstructorReturn(this, (Token.__proto__ || Object.getPrototypeOf(Token)).call(this, superInitialProperties));\n        } else {\n            throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n        }\n        return _possibleConstructorReturn(_this2);\n    }\n\n    _createClass(Token, [{\n        key: \"toString\",\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            return skipNodeClass ? _get(Token.prototype.__proto__ || Object.getPrototypeOf(Token.prototype), \"toString\", this).call(this, true) : 'Token{' + _get(Token.prototype.__proto__ || Object.getPrototypeOf(Token.prototype), \"toString\", this).call(this, true) + '}';\n        }\n    }]);\n\n    return Token;\n}(SyntaxTree_1.Node);\n\nexports.Token = Token;\n;\nObject.defineProperties(Token.prototype, {\n    lexeme: { value: undefined, enumerable: true },\n    parentNodeClass_: { value: Token }\n});\n\nvar SymbolToken = function (_Token) {\n    _inherits(SymbolToken, _Token);\n\n    function SymbolToken(initialProperties) {\n        _classCallCheck(this, SymbolToken);\n\n        if (!(initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n\n        var _this3 = _possibleConstructorReturn(this, (SymbolToken.__proto__ || Object.getPrototypeOf(SymbolToken)).call(this, initialProperties));\n\n        if (initialProperties.symbol) {\n            if (!(initialProperties.symbol instanceof LatexStyle_1.Symbol)) throw new TypeError('\"initialProperties.symbol\" isn\\'t a Symbol instance');\n            Object.defineProperty(_this3, 'symbol', { value: initialProperties.symbol, enumerable: true });\n        } else {\n            if (typeof initialProperties.pattern !== 'string') throw new TypeError('\"initialProperties.pattern\" isn\\'t a string');\n            Object.defineProperty(_this3, 'pattern', { value: initialProperties.pattern });\n        }\n        return _this3;\n    }\n\n    _createClass(SymbolToken, [{\n        key: \"toString\",\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            var source = '';\n            var iParameter = 0;\n            var pattern = this.pattern;\n            for (var nPatternChars = pattern.length, iPatternChar = 0; iPatternChar < nPatternChars; ++iPatternChar) {\n                var patternChar = pattern[iPatternChar];\n                if (patternChar === '#') {\n                    ++iPatternChar;\n                    var parameterToken = this.childNode(iParameter++);\n                    source += parameterToken ? parameterToken.toString(true) : '??';\n                } else {\n                    source += patternChar;\n                }\n            }\n            return skipNodeClass ? source : 'SymbolToken' + (this.symbol ? '' : '[?]') + '{' + source + '}';\n        }\n    }, {\n        key: \"lexeme\",\n        get: function get() {\n            return this.symbol ? this.symbol.lexeme : undefined;\n        }\n    }, {\n        key: \"pattern\",\n        get: function get() {\n            return Utils_1.mustNotBeUndefined(this.symbol).pattern;\n        }\n    }]);\n\n    return SymbolToken;\n}(Token);\n\nexports.SymbolToken = SymbolToken;\n;\nObject.defineProperties(SymbolToken.prototype, {\n    symbol: { value: undefined, enumerable: true }\n});\nObject.defineProperties(SymbolToken.prototype, {\n    pattern: { enumerable: true }\n});\n\nvar ParameterToken = function (_Token2) {\n    _inherits(ParameterToken, _Token2);\n\n    function ParameterToken(initialProperties) {\n        _classCallCheck(this, ParameterToken);\n\n        if (!(initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n\n        var _this4 = _possibleConstructorReturn(this, (ParameterToken.__proto__ || Object.getPrototypeOf(ParameterToken)).call(this, initialProperties));\n\n        if (!initialProperties.hasBrackets) Object.defineProperty(_this4, 'hasBrackets', { value: false, enumerable: true });\n        if (initialProperties.hasSpacePrefix) Object.defineProperty(_this4, 'hasSpacePrefix', { value: true, enumerable: true });\n        return _this4;\n    }\n\n    _createClass(ParameterToken, [{\n        key: \"toString\",\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            var source = this.hasSpacePrefix ? ' ' : '';\n            source += this.hasBrackets ? '{' + _get(ParameterToken.prototype.__proto__ || Object.getPrototypeOf(ParameterToken.prototype), \"toString\", this).call(this, true) + '}' : _get(ParameterToken.prototype.__proto__ || Object.getPrototypeOf(ParameterToken.prototype), \"toString\", this).call(this, true);\n            return skipNodeClass ? source : 'ParameterToken{' + source + '}';\n        }\n    }, {\n        key: \"lexeme\",\n        get: function get() {\n            if (this.parameter && this.parameter.lexeme) return this.parameter.lexeme;\n        }\n    }, {\n        key: \"parameter\",\n        get: function get() {\n            var symbolToken = this.parentNode;\n            var symbol = Utils_1.mustNotBeUndefined(symbolToken.symbol);\n            var parameterIndex = symbolToken.childIndex(this);\n            if (symbolToken !== undefined && parameterIndex !== undefined && parameterIndex >= 0) return symbol.parameter(parameterIndex);\n        }\n    }]);\n\n    return ParameterToken;\n}(Token);\n\nexports.ParameterToken = ParameterToken;\n;\nObject.defineProperties(ParameterToken.prototype, {\n    hasBrackets: { value: true, enumerable: true },\n    hasSpacePrefix: { value: false, enumerable: true },\n    parentNodeClass_: { value: SymbolToken }\n});\nObject.defineProperties(ParameterToken.prototype, {\n    parameter: { enumerable: true }\n});\n\nvar CommandToken = function (_SymbolToken) {\n    _inherits(CommandToken, _SymbolToken);\n\n    function CommandToken(initialProperties) {\n        _classCallCheck(this, CommandToken);\n\n        if (!(initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n        var superInitialProperties = Object.create(initialProperties);\n        if (initialProperties.command) {\n            if (!(initialProperties.command instanceof LatexStyle_1.Command)) throw new TypeError('\"initialProperties.command\" isn\\'t a LatexStyle.Command instance');\n            superInitialProperties.symbol = initialProperties.command;\n\n            var _this5 = _possibleConstructorReturn(this, (CommandToken.__proto__ || Object.getPrototypeOf(CommandToken)).call(this, superInitialProperties));\n        } else {\n            if (typeof initialProperties.name !== 'string') throw new TypeError('\"initialProperties.name\" isn\\'t a string');\n            superInitialProperties.pattern = '';\n\n            var _this5 = _possibleConstructorReturn(this, (CommandToken.__proto__ || Object.getPrototypeOf(CommandToken)).call(this, superInitialProperties));\n\n            Object.defineProperty(_this5, 'name', { value: initialProperties.name });\n        }\n        return _possibleConstructorReturn(_this5);\n    }\n\n    _createClass(CommandToken, [{\n        key: \"toString\",\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            var source = '\\\\' + this.name + _get(CommandToken.prototype.__proto__ || Object.getPrototypeOf(CommandToken.prototype), \"toString\", this).call(this, true);\n            return skipNodeClass ? source : 'CommandToken' + (this.command ? '' : '[?]') + '{' + source + '}';\n        }\n    }, {\n        key: \"command\",\n        get: function get() {\n            return LatexStyle_1.mustBeCommand(this.symbol);\n        }\n    }, {\n        key: \"name\",\n        get: function get() {\n            return this.command.name;\n        }\n    }]);\n\n    return CommandToken;\n}(SymbolToken);\n\nexports.CommandToken = CommandToken;\n;\nObject.defineProperties(CommandToken.prototype, {\n    command: { enumerable: true },\n    name: { enumerable: true }\n});\nfunction isCommandToken(x) {\n    return x && x instanceof CommandToken;\n}\nexports.isCommandToken = isCommandToken;\n\nvar EnvironmentToken = function (_Token3) {\n    _inherits(EnvironmentToken, _Token3);\n\n    function EnvironmentToken(initialProperties) {\n        _classCallCheck(this, EnvironmentToken);\n\n        if (!(initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n\n        var _this6 = _possibleConstructorReturn(this, (EnvironmentToken.__proto__ || Object.getPrototypeOf(EnvironmentToken)).call(this, initialProperties));\n\n        if (!(initialProperties.environment instanceof LatexStyle_1.Environment)) throw new TypeError('\"initialProperties.environment\" isn\\'t a LatexStyle.Environment instance');\n        Object.defineProperty(_this6, 'environment', {\n            value: initialProperties.environment,\n            enumerable: true\n        });\n        return _this6;\n    }\n\n    _createClass(EnvironmentToken, [{\n        key: \"toString\",\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            var beginCommandToken = this.beginCommandToken;\n            var endCommandToken = this.endCommandToken;\n            var bodyToken = this.bodyToken;\n            var source = '\\\\begin{' + this.environment.name + '}';\n            source += beginCommandToken ? SymbolToken.prototype.toString.call(beginCommandToken, true) : '??';\n            source += bodyToken ? bodyToken.toString(true) : '??';\n            source += '\\\\end{' + this.environment.name + '}';\n            source += endCommandToken ? SymbolToken.prototype.toString.call(endCommandToken, true) : '??';\n            return skipNodeClass ? source : 'EnvironmentToken{' + source + '}';\n        }\n    }, {\n        key: \"lexeme\",\n        get: function get() {\n            return this.environment.lexeme;\n        }\n    }, {\n        key: \"beginCommandToken\",\n        get: function get() {\n            var beginCommandToken = this.childNode(0);\n            return beginCommandToken instanceof CommandToken ? beginCommandToken : undefined;\n        }\n    }, {\n        key: \"endCommandToken\",\n        get: function get() {\n            var endCommandToken = this.childNode(2);\n            return endCommandToken instanceof CommandToken ? endCommandToken : undefined;\n        }\n    }, {\n        key: \"bodyToken\",\n        get: function get() {\n            var bodyToken = this.childNode(1);\n            return bodyToken instanceof EnvironmentBodyToken ? bodyToken : undefined;\n        }\n    }]);\n\n    return EnvironmentToken;\n}(Token);\n\nexports.EnvironmentToken = EnvironmentToken;\n;\nObject.defineProperties(EnvironmentToken.prototype, {\n    beginToken: { enumerable: true },\n    endToken: { enumerable: true }\n});\nfunction mustBeEnvironmentToken(x) {\n    if (!isEnvironmentToken(x)) throw new Error();\n    return x;\n}\nexports.mustBeEnvironmentToken = mustBeEnvironmentToken;\nfunction isEnvironmentToken(x) {\n    return x instanceof EnvironmentToken;\n}\nexports.isEnvironmentToken = isEnvironmentToken;\nfunction getBeginCommandToken(x) {\n    if (isCommandToken(x.beginCommandToken)) return x.beginCommandToken;\n}\nfunction getEndCommandToken(x) {\n    if (isCommandToken(x.endCommandToken)) return x.endCommandToken;\n}\nfunction getEnvironment(x) {\n    if (x.environment && LatexStyle_1.isEnvironment(x.environment)) return x.environment;\n}\n\nvar EnvironmentBodyToken = function (_Token4) {\n    _inherits(EnvironmentBodyToken, _Token4);\n\n    function EnvironmentBodyToken() {\n        _classCallCheck(this, EnvironmentBodyToken);\n\n        return _possibleConstructorReturn(this, (EnvironmentBodyToken.__proto__ || Object.getPrototypeOf(EnvironmentBodyToken)).apply(this, arguments));\n    }\n\n    _createClass(EnvironmentBodyToken, [{\n        key: \"toString\",\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            return skipNodeClass ? _get(EnvironmentBodyToken.prototype.__proto__ || Object.getPrototypeOf(EnvironmentBodyToken.prototype), \"toString\", this).call(this, true) : 'EnvironmentBodyToken{' + _get(EnvironmentBodyToken.prototype.__proto__ || Object.getPrototypeOf(EnvironmentBodyToken.prototype), \"toString\", this).call(this, true) + '}';\n        }\n    }, {\n        key: \"environment\",\n        get: function get() {\n            return this.parentNode && getEnvironment(this.parentNode);\n        }\n    }, {\n        key: \"environmentToken\",\n        get: function get() {\n            return this.parentNode && mustBeEnvironmentToken(this.parentNode);\n        }\n    }, {\n        key: \"beginCommandToken\",\n        get: function get() {\n            return this.parentNode && getBeginCommandToken(this.parentNode);\n        }\n    }, {\n        key: \"endCommandToken\",\n        get: function get() {\n            return this.parentNode && getEndCommandToken(this.parentNode);\n        }\n    }]);\n\n    return EnvironmentBodyToken;\n}(Token);\n\nexports.EnvironmentBodyToken = EnvironmentBodyToken;\n;\nObject.defineProperties(EnvironmentBodyToken.prototype, {\n    parentNodeClass_: { value: EnvironmentToken }\n});\n\nvar SpaceToken = function (_Token5) {\n    _inherits(SpaceToken, _Token5);\n\n    function SpaceToken(initialProperties) {\n        _classCallCheck(this, SpaceToken);\n\n        if (initialProperties === undefined) {\n            var _this8 = _possibleConstructorReturn(this, (SpaceToken.__proto__ || Object.getPrototypeOf(SpaceToken)).call(this));\n\n            return _possibleConstructorReturn(_this8);\n        } else if (!(initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n\n        var _this8 = _possibleConstructorReturn(this, (SpaceToken.__proto__ || Object.getPrototypeOf(SpaceToken)).call(this, initialProperties));\n\n        if (initialProperties.lineBreakCount) {\n            if (!isFinite(initialProperties.lineBreakCount) || initialProperties.lineBreakCount < 0) throw new TypeError('\"initialProperties.lineBreakCount\" isn\\'t a non-negative number');\n            Object.defineProperty(_this8, 'lineBreakCount', {\n                value: initialProperties.lineBreakCount,\n                enumerable: true\n            });\n        }\n        return _possibleConstructorReturn(_this8);\n    }\n\n    _createClass(SpaceToken, [{\n        key: \"toString\",\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            if (skipNodeClass) {\n                switch (this.lineBreakCount) {\n                    case 0:\n                        return ' ';\n                    case 1:\n                        return '\\n';\n                    default:\n                        return '\\n\\n';\n                }\n            } else {\n                switch (this.lineBreakCount) {\n                    case 0:\n                        return 'SpaceToken{ }';\n                    case 1:\n                        return 'SpaceToken{\\n}';\n                    default:\n                        return 'SpaceToken{\\n\\n}';\n                }\n            }\n        }\n    }, {\n        key: \"lexeme\",\n        get: function get() {\n            return this.lineBreakCount <= 1 ? \"SPACE\" : \"PARAGRAPH_SEPARATOR\";\n        }\n    }]);\n\n    return SpaceToken;\n}(Token);\n\nexports.SpaceToken = SpaceToken;\n;\nObject.defineProperties(SpaceToken.prototype, {\n    lineBreakCount: { value: 0, enumerable: true }\n});\n\nvar SourceToken = function (_Token6) {\n    _inherits(SourceToken, _Token6);\n\n    function SourceToken(initialProperties) {\n        _classCallCheck(this, SourceToken);\n\n        if (!(initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n\n        var _this9 = _possibleConstructorReturn(this, (SourceToken.__proto__ || Object.getPrototypeOf(SourceToken)).call(this, initialProperties));\n\n        if (!Latex_1.Lexeme[initialProperties.lexeme]) throw new TypeError('\"initialProperties.lexeme\" isn\\'t known');\n        Object.defineProperty(_this9, 'lexeme', { value: initialProperties.lexeme, enumerable: true });\n        if (typeof initialProperties.source !== 'string') throw new TypeError('\"initialProperties.sources\" isn\\'t a string');\n        Object.defineProperty(_this9, 'source', { value: initialProperties.source, enumerable: true });\n        return _this9;\n    }\n\n    _createClass(SourceToken, [{\n        key: \"toString\",\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            return skipNodeClass ? this.source : 'SourceToken[' + this.lexeme + ']{' + this.source + '}';\n        }\n    }]);\n\n    return SourceToken;\n}(Token);\n\nexports.SourceToken = SourceToken;\n;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Utils_1 = __webpack_require__(0);\n'use strict';\n\nvar SyntaxTree = function SyntaxTree(rootNode, source) {\n    _classCallCheck(this, SyntaxTree);\n\n    if (!(rootNode instanceof Node)) throw new TypeError('\"rootNode\" isn\\'t a SyntaxTree.Node instance');\n    if (rootNode.parentNode) throw new TypeError('\"rootNode\" has a parent node');\n    if (rootNode.tree) throw new TypeError('\"rootNode\" is a tree root');\n    if (typeof source !== 'string') throw new TypeError('\"sources\" isn\\'t a string');\n    Object.defineProperty(this, 'rootNode', { value: rootNode, enumerable: true });\n    Object.defineProperty(this, 'source', { value: source, enumerable: true });\n    Object.defineProperty(rootNode, 'tree', { value: this, enumerable: true });\n};\n\nexports.SyntaxTree = SyntaxTree;\n;\n\nvar Node = function () {\n    function Node(opt_initialProperties) {\n        _classCallCheck(this, Node);\n\n        if (opt_initialProperties !== undefined) {\n            if (!(opt_initialProperties instanceof Object)) throw new TypeError('initialProperties isn\\'t an Object instance');\n            if (opt_initialProperties.childNodes !== undefined) {\n                if (!(opt_initialProperties.childNodes instanceof Array)) throw new TypeError('initialProperties.childNodes isn\\'t an Array instance');\n                opt_initialProperties.childNodes.forEach(this.insertChildSubtree, this);\n            }\n            var optParentNode = opt_initialProperties.parentNode;\n            if (optParentNode !== undefined) {\n                if (!!optParentNode) {\n                    optParentNode.insertChildSubtree(this);\n                } else {\n                    throw new TypeError('initialProperties.parentNode isn\\'t a SyntaxTree.Node instance');\n                }\n            }\n        }\n    }\n\n    _createClass(Node, [{\n        key: \"childNode\",\n        value: function childNode(node) {\n            if (Utils_1.isNumber(node)) return this.childNodes_[node] || undefined;\n            if (node instanceof Node) return node.parentNode === this ? node : undefined;\n            throw new TypeError('\"node\" is neither a number nor a SyntaxTree.Node instance');\n        }\n    }, {\n        key: \"childIndex\",\n        value: function childIndex(node) {\n            if (Utils_1.isNumber(node)) return this.childNodes_[node] ? node : undefined;\n            if (node instanceof Node) return node.parentNode === this ? this.childNodes_.indexOf(node) : undefined;\n            throw new TypeError('\"node\" is neither a number nor a SyntaxTree.Node instance');\n        }\n    }, {\n        key: \"insertChildNode\",\n        value: function insertChildNode(node, childIndex, childNodesToCover) {\n            if (!(node instanceof Node)) throw new TypeError('\"node\" isn\\'t a SyntaxTree.Node instance');\n            if (node.parentNode) throw new TypeError('\"node\" has a parent');\n            if (node.tree) throw new TypeError('\"node\" is a tree root');\n            if (node.childNodes_.length) throw new TypeError('\"node\" has child nodes');\n            if (!this.hasOwnProperty('childNodes_')) Object.defineProperty(this, 'childNodes_', { value: [], configurable: true });\n            if (childIndex === undefined) childIndex = this.childNodes_.length;\n            if (childNodesToCover === undefined) childNodesToCover = 0;\n            var nodeChildNodes = this.childNodes_.splice(childIndex, childNodesToCover, node);\n            Object.defineProperty(this, 'subtreeSize', {\n                value: this.subtreeSize + 1,\n                enumerable: true,\n                configurable: true\n            });\n            for (var parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\n                Object.defineProperty(parentNode, 'subtreeSize', { value: parentNode.subtreeSize + 1 });\n            }\n            Object.defineProperty(node, 'parentNode', {\n                value: this,\n                enumerable: true,\n                configurable: true\n            });\n            if (nodeChildNodes.length) {\n                Object.defineProperty(node, 'childNodes_', { value: nodeChildNodes, configurable: true });\n                var subtreeSize = 1;\n                nodeChildNodes.forEach(function (nodeChildNode) {\n                    subtreeSize += nodeChildNode.subtreeSize;\n                });\n                Object.defineProperty(node, 'subtreeSize', {\n                    value: subtreeSize,\n                    enumerable: true,\n                    configurable: true\n                });\n            }\n            return node;\n        }\n    }, {\n        key: \"insertChildSubtree\",\n        value: function insertChildSubtree(node, childIndex) {\n            if (!(node instanceof Node)) throw new TypeError('\"node\" isn\\'t a SyntaxTree.Node instance');\n            if (node.parentNode) throw new TypeError('\"node\" has a parent');\n            if (node.tree) throw new TypeError('\"node\" is a tree root');\n            if (!this.hasOwnProperty('childNodes_')) Object.defineProperty(this, 'childNodes_', { value: [], configurable: true });\n            if (childIndex === undefined) childIndex = this.childNodes_.length;\n            this.childNodes_.splice(childIndex, 0, node);\n            var nodeSubtreeSize = node.subtreeSize;\n            Object.defineProperty(this, 'subtreeSize', {\n                value: this.subtreeSize + nodeSubtreeSize, enumerable: true, configurable: true\n            });\n            for (var parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\n                Object.defineProperty(parentNode, 'subtreeSize', {\n                    value: parentNode.subtreeSize + nodeSubtreeSize\n                });\n            }\n            Object.defineProperty(node, 'parentNode', {\n                value: this,\n                enumerable: true,\n                configurable: true\n            });\n        }\n    }, {\n        key: \"removeChildNode\",\n        value: function removeChildNode(nodeOrNodeIndex) {\n            var _childNodes_;\n\n            var nodeChildIndex = this.childIndex(nodeOrNodeIndex);\n            if (nodeChildIndex === undefined) return undefined;\n            var node = this.childNodes_[nodeChildIndex];\n            (_childNodes_ = this.childNodes_).splice.apply(_childNodes_, [nodeChildIndex, 1].concat(_toConsumableArray(node.childNodes_)));\n            if (this.childNodes_.length) {\n                Object.defineProperty(this, 'subtreeSize', { value: this.subtreeSize - 1 });\n            } else {\n                delete this.childNodes_;\n                delete this.subtreeSize;\n            }\n            for (var parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\n                Object.defineProperty(parentNode, 'subtreeSize', { value: parentNode.subtreeSize - 1 });\n            }\n            delete node.parentNode;\n            delete node.childNodes_;\n            delete node.subtreeSize;\n            return node;\n        }\n    }, {\n        key: \"removeChildSubtree\",\n        value: function removeChildSubtree(node) {\n            var nodeChildIndex = this.childIndex(node);\n            if (nodeChildIndex === undefined) return undefined;\n            node = this.childNodes_.splice(nodeChildIndex, 1)[0];\n            var nodeSubtreeSize = node.subtreeSize;\n            if (this.childNodes_.length) {\n                Object.defineProperty(this, 'subtreeSize', { value: this.subtreeSize - nodeSubtreeSize });\n            } else {\n                delete this.childNodes_;\n                delete this.subtreeSize;\n            }\n            for (var parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\n                Object.defineProperty(parentNode, 'subtreeSize', {\n                    value: parentNode.subtreeSize - nodeSubtreeSize\n                });\n            }\n            delete node.parentNode;\n            return node;\n        }\n    }, {\n        key: \"toString\",\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            var source = '';\n            this.childNodes_.forEach(function (childNode) {\n                source += childNode.toString(true);\n            });\n            return skipNodeClass ? source : 'SourceTree.Node{' + source + '}';\n        }\n    }, {\n        key: \"childNodes\",\n        get: function get() {\n            return this.childNodes_.slice();\n        }\n    }]);\n\n    return Node;\n}();\n\nexports.Node = Node;\n;\nObject.defineProperties(Node.prototype, {\n    childNodes: { enumerable: true }\n});\nObject.defineProperties(Node.prototype, {\n    tree: { value: undefined, enumerable: true },\n    parentNode: { value: undefined, enumerable: true },\n    subtreeSize: { value: 1, enumerable: true },\n    childNodes_: { value: [], enumerable: false },\n    parentNodeClass_: { value: Node, enumerable: false }\n});\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar LatexStyle_1 = __webpack_require__(2);\nvar LatexTree_1 = __webpack_require__(3);\nvar Latex_1 = __webpack_require__(1);\nvar Utils_1 = __webpack_require__(0);\nfunction parseCommentLine_(context) {\n    var commentMatch = context.source.substring(context.position).match(/^%([^\\n]*)(\\n[ \\t]*)?/);\n    if (!commentMatch) return false;\n    context.comments.push(commentMatch[1]);\n    context.position += commentMatch[0].length;\n    if (!commentMatch[2]) {\n        context.charNumber += commentMatch[0].length;\n    } else {\n        ++context.lineNumber;\n        context.charNumber = commentMatch[2].length - 1;\n    }\n    return true;\n}\nfunction processParsedToken_(context, token) {\n    if (context.currentToken) {\n        context.currentToken.insertChildSubtree(token);\n    }\n}\nfunction parseSpaceToken_(context) {\n    var isSpace = false;\n    var nLineBreaks = 0;\n    while (context.position < context.source.length) {\n        if (parseCommentLine_(context)) continue;\n        switch (context.source[context.position]) {\n            case ' ':\n            case '\\t':\n                isSpace = true;\n                ++context.position;\n                ++context.charNumber;\n                continue;\n            case '\\n':\n                isSpace = true;\n                ++nLineBreaks;\n                ++context.position;\n                ++context.lineNumber;\n                context.charNumber = 0;\n                continue;\n        }\n        break;\n    }\n    return isSpace ? new LatexTree_1.SpaceToken({ lineBreakCount: nLineBreaks }) : undefined;\n}\n\nvar LatexParser = function () {\n    function LatexParser(latexStyle) {\n        _classCallCheck(this, LatexParser);\n\n        if (!(latexStyle instanceof LatexStyle_1.default)) throw new TypeError('\"latexStyle\" isn\\'t a LatexStyle instance');\n        Object.defineProperty(this, 'latexStyle', { value: latexStyle, enumerable: true });\n    }\n\n    _createClass(LatexParser, [{\n        key: \"parse\",\n        value: function parse(source, opt_context) {\n            if (typeof source !== 'string') throw new TypeError('\"sources\" isn\\'t a string');\n            var context = void 0;\n            if (opt_context === undefined) {\n                context = new Context(source);\n            } else if (opt_context instanceof Context) {\n                context = opt_context;\n                context.source += source;\n            } else {\n                throw new TypeError('\"context\" isn\\'t a LatexParser.Context instance');\n            }\n            var parsedTokens = [];\n            while (true) {\n                var parsedToken = this.parseToken_(context);\n                if (parsedToken === undefined) break;\n                parsedTokens.push(parsedToken);\n            }\n            return parsedTokens;\n        }\n    }, {\n        key: \"parseToken_\",\n        value: function parseToken_(context) {\n            var token = parseSpaceToken_(context);\n            if (!token) {\n                if (context.position >= context.source.length) return undefined;\n                var contextBackup = context.copy();\n                if (!(token = this.parseEnvironmentToken_(context))) {\n                    contextBackup.copy(context);\n                    if (!(token = this.parseCommandToken_(context))) {\n                        contextBackup.copy(context);\n                        if (!(token = this.parseSymbolsToken_(context))) {\n                            return undefined;\n                        }\n                    }\n                }\n            }\n            processParsedToken_(context, token);\n            return token;\n        }\n    }, {\n        key: \"parseParameterToken_\",\n        value: function parseParameterToken_(context, parameter, opt_endLabel) {\n            var currentTokenBackup = context.currentToken;\n            context.updateState(parameter.operations);\n            if (opt_endLabel === undefined) {\n                var spacePrefixState = parseSpaceToken_(context) !== undefined;\n                if (context.source[context.position] === '{') {\n                    context.currentToken = new LatexTree_1.ParameterToken({ hasBrackets: true, hasSpacePrefix: spacePrefixState });\n                    ++context.position;\n                    ++context.charNumber;\n                    if (!this.parseUntilLabel_(context, '}', parameter.lexeme)) return undefined;\n                    ++context.position;\n                    ++context.charNumber;\n                } else {\n                    context.currentToken = new LatexTree_1.ParameterToken({ hasBrackets: false, hasSpacePrefix: spacePrefixState });\n                    if (this.parseToken_(context) === undefined) return undefined;\n                }\n            } else {\n                context.currentToken = new LatexTree_1.ParameterToken({ hasBrackets: false, hasSpacePrefix: false });\n                if (!this.parseUntilLabel_(context, opt_endLabel, parameter.lexeme)) return undefined;\n            }\n            var parameterToken = context.currentToken;\n            context.currentToken = currentTokenBackup;\n            processParsedToken_(context, parameterToken);\n            return parameterToken;\n        }\n    }, {\n        key: \"parseEnvironmentToken_\",\n        value: function parseEnvironmentToken_(context) {\n            if (!context.source.startsWith('\\\\begin', context.position)) return undefined;\n            context.position += 6;\n            parseSpaceToken_(context);\n            var nameMatch = context.source.substring(context.position).match(/^{([\\w@]+\\*?)}/);\n            if (!nameMatch) return undefined;\n            var name = nameMatch[1];\n            context.position += nameMatch[0].length;\n            context.charNumber += nameMatch[0].length;\n            var currentTokenBackup = context.currentToken;\n            var environment = this.latexStyle.environments(context.currentState, name)[0];\n            var environmentToken = context.currentToken = environment ? new LatexTree_1.EnvironmentToken({ environment: environment.environment }) : new LatexTree_1.EnvironmentToken({ name: name });\n            var symbols = this.latexStyle.commands(context.currentState, name);\n            var beginCommandToken = this.parsePatterns_(context, symbols);\n            if (beginCommandToken === undefined) {\n                beginCommandToken = new LatexTree_1.CommandToken({ name: name });\n            }\n            processParsedToken_(context, beginCommandToken);\n            var environmentBodyToken = context.currentToken = new LatexTree_1.EnvironmentBodyToken();\n            var endFound = this.parseUntilLabel_(context, '\\\\end{' + name + '}');\n            context.currentToken = environmentToken;\n            processParsedToken_(context, environmentBodyToken);\n            var endCommandToken = undefined;\n            if (endFound) {\n                context.position += name.length + 6;\n                context.charNumber += name.length + 6;\n                endCommandToken = this.parsePatterns_(context, this.latexStyle.commands(context.currentState, 'end' + name));\n            } else {}\n            if (endCommandToken === undefined) {\n                endCommandToken = new LatexTree_1.CommandToken({ name: 'end' + name });\n            }\n            processParsedToken_(context, endCommandToken);\n            context.currentToken = currentTokenBackup;\n            return environmentToken;\n        }\n    }, {\n        key: \"parseCommandToken_\",\n        value: function parseCommandToken_(context) {\n            var cmdMatch = context.source.substring(context.position).match(/^\\\\([\\w@]+\\*?)/);\n            if (!cmdMatch) return undefined;\n            context.position += cmdMatch[0].length;\n            context.charNumber += cmdMatch[0].length;\n            var token = this.parsePatterns_(context, this.latexStyle.commands(context.currentState, cmdMatch[1]));\n            if (token === undefined) {\n                token = new LatexTree_1.CommandToken({ name: cmdMatch[1] });\n            }\n            return token;\n        }\n    }, {\n        key: \"parseSymbolsToken_\",\n        value: function parseSymbolsToken_(context) {\n            var sourceCharacter = context.source[context.position];\n            var token = this.parsePatterns_(context, this.latexStyle.symbols(context.currentState, sourceCharacter));\n            if (token === undefined) {\n                ++context.position;\n                ++context.charNumber;\n                token = new LatexTree_1.SymbolToken({ pattern: sourceCharacter });\n            } else {}\n            return token;\n        }\n    }, {\n        key: \"parsePatterns_\",\n        value: function parsePatterns_(context, symbols) {\n            var _this = this;\n\n            var contextBackup = context.copy();\n            var token = undefined;\n            symbols.some(function (symbol) {\n                if (token = _this.parsePattern_(context, symbol)) {\n                    return true;\n                } else {\n                    contextBackup.copy(context);\n                    return false;\n                }\n            });\n            return token;\n        }\n    }, {\n        key: \"parsePattern_\",\n        value: function parsePattern_(context, symbol) {\n            var currentTokenBackup = context.currentToken;\n            context.currentToken = symbol instanceof LatexStyle_1.Command ? new LatexTree_1.CommandToken({ command: symbol }) : new LatexTree_1.SymbolToken({ symbol: symbol });\n            var patternComponents = symbol.patternComponents;\n            var nPatternComponents = patternComponents.length;\n            var iPatternComponent = 0;\n            for (; iPatternComponent < nPatternComponents; ++iPatternComponent) {\n                var patternComponent = patternComponents[iPatternComponent];\n                if (Utils_1.isNumber(patternComponent)) {\n                    var parameter = symbol.parameter(patternComponent);\n                    var parameterEndLabel = patternComponents[iPatternComponent + 1];\n                    if (typeof parameterEndLabel === 'string') {\n                        if (this.parseParameterToken_(context, Utils_1.mustNotBeUndefined(parameter), parameterEndLabel)) {\n                            if (!context.source.startsWith(parameterEndLabel, context.position)) return undefined;\n                            context.position += parameterEndLabel.length;\n                            context.charNumber += parameterEndLabel.length;\n                            ++iPatternComponent;\n                            continue;\n                        }\n                    } else {\n                        if (this.parseParameterToken_(context, Utils_1.mustNotBeUndefined(parameter))) continue;\n                    }\n                } else if (Utils_1.isString(patternComponent)) {\n                    while (parseCommentLine_(context)) {}\n                    if (context.source.startsWith(patternComponent, context.position)) {\n                        context.position += patternComponent.length;\n                        context.charNumber += patternComponent.length;\n                        continue;\n                    }\n                } else if (parseSpaceToken_(context)) continue;\n                break;\n            }\n            if (iPatternComponent < nPatternComponents) return undefined;\n            var parsedToken = context.currentToken;\n            context.currentToken = currentTokenBackup;\n            context.updateState(symbol.operations);\n            return parsedToken;\n        }\n    }, {\n        key: \"parseUntilLabel_\",\n        value: function parseUntilLabel_(context, endLabel, opt_lexeme) {\n            switch (opt_lexeme) {\n                default:\n                    {\n                        while (!context.source.startsWith(endLabel, context.position)) {\n                            if (context.position >= context.source.length) {\n                                return false;\n                            }\n                            this.parseToken_(context);\n                        }\n                        return true;\n                    }\n            }\n        }\n    }]);\n\n    return LatexParser;\n}();\n\nexports.LatexParser = LatexParser;\n;\n\nvar Context = function () {\n    function Context() {\n        var opt_source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n\n        _classCallCheck(this, Context);\n\n        this.source = opt_source || '';\n        this.position = 0;\n        this.lineNumber = 0;\n        this.charNumber = 0;\n        this.currentToken = undefined;\n        this.currentState = new Latex_1.State();\n        this.stateStack = [];\n        this.comments = [];\n    }\n\n    _createClass(Context, [{\n        key: \"copy\",\n        value: function copy(opt_target) {\n            var target = opt_target || new Context();\n            target.source = this.source;\n            target.position = this.position;\n            target.lineNumber = this.lineNumber;\n            target.charNumber = this.charNumber;\n            target.currentToken = this.currentToken;\n            target.currentState = this.currentState.copy();\n            target.stateStack = this.stateStack.slice();\n            target.comments = this.comments.slice();\n            return target;\n        }\n    }, {\n        key: \"updateState\",\n        value: function updateState(operations) {\n            var _this2 = this;\n\n            if (!(operations instanceof Array)) throw new TypeError('\"operations\" isn\\'t an Array instance');\n            var newModeStates = {};\n            operations.forEach(function (operation) {\n                switch (operation.directive) {\n                    case Latex_1.Directive.BEGIN:\n                        switch (operation.operand) {\n                            case Latex_1.GROUP:\n                                _this2.currentState.update(newModeStates);\n                                newModeStates = {};\n                                _this2.stateStack.push(_this2.currentState.copy());\n                                break;\n                            default:\n                                newModeStates[operation.operand] = true;\n                        }\n                        break;\n                    case Latex_1.Directive.END:\n                        switch (operation.operand) {\n                            case Latex_1.GROUP:\n                                newModeStates = {};\n                                if (_this2.stateStack.length < 1) throw new Error('state stack is empty');\n                                _this2.currentState = Utils_1.mustNotBeUndefined(_this2.stateStack.pop());\n                                break;\n                            default:\n                                newModeStates[operation.operand] = false;\n                        }\n                        break;\n                }\n            });\n            this.currentState.update(newModeStates);\n        }\n    }]);\n\n    return Context;\n}();\n\nexports.Context = Context;\n;\nexports.default = LatexParser;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction __export(m) {\n    for (var p in m) {\n        if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n    }\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(0));\n__export(__webpack_require__(1));\n__export(__webpack_require__(2));\n__export(__webpack_require__(4));\n__export(__webpack_require__(3));\n__export(__webpack_require__(5));\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// latex-parser.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c36f79df34992f3b485d","/**\r\n * @fileoverview General JavaScript utils\r\n * This file is a part of TeXnous project.\r\n *\r\n * @copyright TeXnous project team (http://texnous.org) 2016\r\n * @license LGPL-3.0\r\n *\r\n * This library is free software; you can redistribute it and/or modify it under the terms of the\r\n * GNU Lesser General Public License as published by the Free Software Foundation; either version 3\r\n * of the License, or (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\r\n * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License along with this library;\r\n * if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\r\n * 02111-1307, USA.\r\n */\r\n\r\nexport type StringMap = {[s:string]:string};\r\n\r\nexport type TargetObject = any;\r\nexport type ValuesObject = any;\r\n\r\nexport type OptKeys = StringMap | string[];\r\n\r\nexport interface OptAttributes {\r\n  writable: boolean;\r\n  enumerable: boolean;\r\n  configurable: boolean;\r\n}\r\n/**\r\n * Update object properties by property values\r\n * @param {!Object} target the object to copy properties to\r\n * @param {!Object} values the object with property values (undefined values will be skipped)\r\n * @param {(!Object.<string,string>|!Array.<string>)=} opt_keys\r\n *        list of keys or map of the target keys to the property names, all the enumerable\r\n *        properties will be used if undefined\r\n * @param {{writable:boolean,enumerable:boolean,configurable:boolean}=} opt_attributes\r\n *        property attributes, { writable: true, enumerable: true, configurable: true } by default\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport function updateProperties(target: TargetObject,\r\n                                 values: ValuesObject,\r\n                                 opt_keys?: OptKeys,\r\n                                 opt_attributes: OptAttributes = { writable: true, enumerable: true, configurable: true }) {\r\n  if (!(target instanceof Object)) throw new TypeError('\"target\" isn\\'t an Object instance');\r\n  if (values === undefined) return; // do noting is the sources is undefined\r\n  if (!(values instanceof Object)) throw new TypeError('\"properties\" isn\\'t an Object instance');\r\n  if (opt_attributes === undefined) {\r\n    opt_attributes = { writable: true, enumerable: true, configurable: true };\r\n  } else if (!(opt_attributes instanceof Object)) {\r\n    throw new TypeError('\"attributes\" isn\\'t an Object instance')\r\n  }\r\n  if (opt_keys === undefined) { // if the key map isn't defined\r\n    for (let key in values) { // for all the enumerable properties\r\n      //noinspection JSUnfilteredForInLoop\r\n      if (values[key] !== undefined) {\r\n        //noinspection JSUnfilteredForInLoop\r\n        Object.defineProperty(target, key, // update the property\r\n          // using the defined value\r\n          Object.create(opt_attributes, { value: { value: values[key] } })\r\n        );\r\n      }\r\n    }\r\n  } else if (opt_keys instanceof Array) { // if the list of the keys is defined\r\n    opt_keys.forEach(key => { if (values[key] !== undefined) {\r\n      Object.defineProperty(target, key, // update the property\r\n        Object.create(opt_attributes, {value: {value: values[key]}}) // using the defined value\r\n      );\r\n    }});\r\n  } else if (opt_keys instanceof Object) { // if the map of the keys is defined\r\n    for (let targetKey in opt_keys) { // for all the target keys\r\n      //noinspection JSUnfilteredForInLoop\r\n      let key = opt_keys[targetKey]; // the sources key\r\n      if (values[key] !== undefined)\r\n        //noinspection JSUnfilteredForInLoop\r\n        Object.defineProperty(target, targetKey, // update the property\r\n          // using the defined value\r\n          Object.create(opt_attributes, { value: { value: values[key] } })\r\n        );\r\n    }\r\n  } else { // if \"keys\" has unsupported value\r\n    throw new TypeError('\"keys\" isn\\'t an Object instance');\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Test object properties with property values (strict comparing is used)\r\n * @param {!Object} target the object with properties to test\r\n * @param {?Object} values the object with property values (undefined values will be skipped)\r\n * @param {?(Object.<string,string>|Array.<string>)} opt_keys\r\n *        list of keys or map of the target keys to the property names, all the enumerable\r\n *        properties will be used if undefined\r\n * @param {boolean=true} opt_skipUndefined true to skip keys with undefined values, false otherwise\r\n * @return {boolean} true if all the defined properties are the same false otherwise\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport function testProperties(target: TargetObject,\r\n                               values?: ValuesObject,\r\n                               opt_keys?: OptKeys,\r\n                               opt_skipUndefined: boolean = true) {\r\n  if (!(target instanceof Object)) throw new TypeError('\"target\" isn\\'t an Object instance');\r\n  if (values === undefined) return true; // do noting is the sources is undefined\r\n  if (!(values instanceof Object)) throw new TypeError('\"properties\" isn\\'t an Object instance');\r\n  if (opt_skipUndefined === undefined) opt_skipUndefined = true; // skip undefined by default\r\n\r\n  if (opt_keys === undefined) { // if the key map isn't defined\r\n    for (let key in values) { // for all the enumerable properties\r\n      if (target[key] !== values[key] && !(values[key] === undefined && opt_skipUndefined))\r\n        return false; // false if any value is different\r\n    }\r\n  } else if (opt_keys instanceof Array) { // if the list of the keys is defined\r\n    return opt_keys.every(key => {\r\n      return target[key] === values[key] || (values[key] === undefined && opt_skipUndefined);\r\n    });\r\n  } else if (opt_keys instanceof Object) { // if the map of the keys is defined\r\n    for (let targetKey in opt_keys) { // for all the target keys\r\n      let key = opt_keys[targetKey]; // the sources key\r\n      if (target[targetKey] !== values[key] && !(values[key] === undefined && opt_skipUndefined))\r\n        return false; // false if any value is different\r\n    }\r\n  } else { // if \"keys\" has unsupported value\r\n    throw new TypeError('\"keys\" isn\\'t an Object instance');\r\n  }\r\n  return true; // return true if all the defined properties are the same\r\n};\r\n\r\n\r\nexport function isNumber(x: any): x is number {\r\n  return typeof x === \"number\"\r\n}\r\n\r\nexport function isString(x: any): x is string {\r\n  return typeof x === \"string\"\r\n}\r\n\r\nexport function mustNotBeUndefined<T>(x?: T): T {\r\n  if(!x) throw new Error();\r\n  return x;\r\n}\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/Utils.ts","/**\r\n * @fileoverview General LaTeX definitions\r\n * This file is a part of TeXnous project.\r\n *\r\n * @copyright TeXnous project team (http://texnous.org) 2016\r\n * @license LGPL-3.0\r\n *\r\n * This library is free software; you can redistribute it and/or modify it under the terms of the\r\n * GNU Lesser General Public License as published by the Free Software Foundation; either version 3\r\n * of the License, or (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\r\n * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License along with this library;\r\n * if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\r\n * 02111-1307, USA.\r\n */\r\n\r\n'use strict';\r\n\r\n/**@module */\r\n\r\n\r\n\r\n/**\r\n * LaTeX lexeme\r\n * @enum {string}\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport const Lexeme = {\r\n  BINARY_OPERATOR:     'BINARY_OPERATOR',     // mathematical binary operator\r\n  BRACKETS:            'BRACKETS',            // logical brackets\r\n  CELL_SEPARATOR:      'CELL_SEPARATOR',      // table cell separator\r\n  CHAR:                'CHAR',                // character\r\n  DIGIT:               'DIGIT',               // digit\r\n  DIRECTIVE:           'DIRECTIVE',           // LaTeX directive\r\n  DISPLAY_EQUATION:    'DISPLAY_EQUATION',    // mathematical equation for display mode\r\n  FILE_PATH:           'FILE_PATH',           // file system path\r\n  FLOATING_BOX:        'FLOATING_BOX',        // floating box\r\n  HORIZONTAL_SKIP:     'HORIZONTAL_SKIP',     // any type of horizontal skip but not space\r\n  INLINE_EQUATION:     'INLINE_EQUATION',     // mathematical equation for inline mode\r\n  LABEL:               'LABEL',               // label identifier\r\n  LENGTH:              'LENGTH',              // linear dimension\r\n  LETTER:              'LETTER',              // word letter\r\n  LINE_BREAK:          'LINE_BREAK',          // text line break\r\n  LIST_ITEM:           'LIST_ITEM',           // list item\r\n  LIST:                'LIST',                // list of items\r\n  NUMBER:              'NUMBER',              // sequence of digits\r\n  PARAGRAPH_SEPARATOR: 'PARAGRAPH_SEPARATOR', // paragraph separator\r\n  PICTURE:             'PICTURE',             // picture\r\n  POST_OPERATOR:       'POST_OPERATOR',       // mathematical post-operator\r\n  PRE_OPERATOR:        'PRE_OPERATOR',        // mathematical pre-operator\r\n  RAW:                 'RAW',                 // unprocessable or raw sources\r\n  SPACE:               'SPACE',               // any type of space equivalent\r\n  SUBSCRIPT:           'SUBSCRIPT',           // subscript text\r\n  SUPERSCRIPT:         'SUPERSCRIPT',         // subscript text\r\n  TABLE:               'TABLE',               // table\r\n  TABULAR_PARAMETERS:  'TABULAR_PARAMETERS',  // LaTeX tabular parameters\r\n  TAG:                 'TAG',                 // formatting tag\r\n  UNKNOWN:             'UNKNOWN',             // unrecognized element\r\n  VERTICAL_SKIP:       'VERTICAL_SKIP',       // any type of vertical skip\r\n  WORD:                'WORD',                // sequence of letters\r\n  WRAPPER:             'WRAPPER'              // wrapper for something\r\n};\r\nexport type Lexeme = keyof typeof Lexeme;\r\n\r\n/**\r\n * LaTeX modes\r\n * @enum {string}\r\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n */\r\nexport const modes = {\r\n  LIST:     'LIST',    // list of items\r\n  MATH:     'MATH',    // mathematical expressionLatex\r\n  PICTURE:  'PICTURE', // picture\r\n  TABLE:    'TABLE',   // LaTeX tabular\r\n  TEXT:     'TEXT',    // general text\r\n  VERTICAL: 'VERTICAL' // vertical spacing\r\n};\r\n\r\nexport type Mode = keyof typeof modes;\r\n\r\nexport function isMode(x: any): x is Mode {\r\n  return modes.hasOwnProperty(x);\r\n}\r\n\r\nexport function mustBeMode(x: any): Mode {\r\n  if(!isMode(x)) throw new Error();\r\n  return x;\r\n}\r\n\r\nexport type ModeStates = {[mode: string]: boolean};\r\n/**\r\n * LaTeX state encapsulation\r\n * @class\r\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n */\r\nexport class State {\r\n  private modeStates_: ModeStates;\r\n\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!Object.<Mode,boolean>=} opt_initialModeStates the initial mode states\r\n   * @constructor\r\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n   */\r\n  constructor(opt_initialModeStates: ModeStates = {}) {\r\n    Object.defineProperty(this, 'modeStates_', { value: { }, enumerable: false });\r\n\r\n    this.modeStates_[modes.LIST]     = false;\r\n\r\n    this.modeStates_[modes.MATH]     = false;\r\n\r\n    this.modeStates_[modes.PICTURE]  = false;\r\n\r\n    this.modeStates_[modes.TABLE]    = false;\r\n\r\n    this.modeStates_[modes.TEXT]     = true;\r\n    //noinspection JSUnresolvedVariable\r\n    this.modeStates_[modes.VERTICAL] = false;\r\n    // update the mode states\r\n    if (opt_initialModeStates !== undefined) this.update(opt_initialModeStates);\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Create a copy of this state.\r\n   * @return {!State} the created copy\r\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n   */\r\n  copy() {\r\n    //noinspection JSValidateTypes,JSUnresolvedVariable\r\n    return new State(this.modeStates_);\r\n  }\r\n\r\n\r\n  /**\r\n   * Update the state with states for modes\r\n   * @param {!Object.<Mode,boolean>} modeStates the states for modes\r\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n   */\r\n  update(modeStates: ModeStates) {\r\n    for (let modeKey in modeStates) { // for all the given modes\r\n      //noinspection JSUnfilteredForInLoop\r\n      let mode = modes[mustBeMode(modeKey)]; // verify the mode key\r\n      if (mode === undefined) // if the mode is unknown\r\n        throw new TypeError('\"modeStates[' + modeKey + ']\" isn\\'t a Latex.Mode option');\r\n      //noinspection JSUnfilteredForInLoop,JSUnresolvedVariable\r\n      this.modeStates_[mode] = modeStates[modeKey]; // store the mode state\r\n    }\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Test the state with mode states\r\n   * @param {!Object.<Mode,boolean>} modeStates the states for modes\r\n   * @return {boolean} true if the state fits the modes, false otherwise\r\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n   */\r\n  test(modeStates: ModeStates) {\r\n    for (let modeKey in modeStates) { // for all the given modes\r\n      let mode = modes[mustBeMode(modeKey)]; // verify the mode key\r\n      if (mode === undefined) // if the mode is unknown\r\n        throw new TypeError('\"modeStates[' + modeKey + ']\" isn\\'t a Latex.Mode option');\r\n      // exit if the mode has different states\r\n      if (this.modeStates_[mode] !== modeStates[modeKey]) return false;\r\n    }\r\n    return true;\r\n  }\r\n};\r\n\r\n\r\n\r\n/**\r\n * LaTeX directive\r\n * @enum {string}\r\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n */\r\nexport const Directive = {\r\n  BEGIN: 'BEGIN', // begin something\r\n  END:   'END'    // end something\r\n};\r\nexport type Directive = keyof typeof Directive;\r\n\r\n\r\n/**\r\n * Group operand for directives\r\n * @const {string}\r\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n */\r\nexport const GROUP = 'GROUP';\r\nexport type GROUP = 'GROUP';\r\n\r\n\r\n\r\n/**\r\n * LaTeX operation properties\r\n * @interface OperationProperties\r\n * @property {Directive} directive - The directive or undefined if there is no a directive\r\n * @property {Mode|GROUP} operand - The operand or undefined if there is no an operand\r\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n */\r\nexport interface OperationProperties {\r\n  directive: Directive;\r\n  operand: Mode|GROUP;\r\n}\r\nexport function isOperationProperties(x: any): x is OperationProperties {\r\n  return x && x.hasOwnProperty(\"directive\") && x.hasOwnProperty(\"operand\");\r\n}\r\n\r\nexport function mustBeOperationProperties(x: any): OperationProperties {\r\n  if(!isOperationProperties(x)) throw new Error();\r\n  return x;\r\n}\r\n\r\n/**\r\n * LaTeX operation encapsulation\r\n * @class\r\n * @property {Directive} directive - The directive or undefined if there is no a directive\r\n * @property {Mode|GROUP} operand - The operand or undefined if there is no an operand\r\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n */\r\nexport class Operation {\r\n  directive: Directive;\r\n  operand: Mode | GROUP;\r\n\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!OperationProperties=} opt_initialProperties the initial property values\r\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n   */\r\n  constructor(opt_initialProperties?: OperationProperties) {\r\n    // do nothing if the initial properties aren't defined\r\n    if (opt_initialProperties === undefined) return;\r\n    if (!(opt_initialProperties instanceof Object))\r\n      throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\r\n    let directive = Directive[opt_initialProperties.directive]; // validate the directive\r\n    if (!directive)\r\n      throw new TypeError('\"initialProperties.directive\" isn\\'t an Latex.Directive option');\r\n    Object.defineProperty(this, 'directive', { value: directive, enumerable: true });\r\n    switch (opt_initialProperties.operand) {\r\n    case GROUP: // if operand is a group\r\n      // store the operand\r\n      Object.defineProperty(this, 'operand', { value: GROUP, enumerable: true });\r\n      break;\r\n    default:\r\n      let mode = modes[opt_initialProperties.operand]; // validate the operand as a mode\r\n      if (!mode) throw new TypeError('\"initialProperties.operand\" isn\\'t an Latex.Mode option');\r\n      // store the operand\r\n      Object.defineProperty(this, 'operand', { value: mode, enumerable: true });\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Compare this operation with the other\r\n   * @param {!Operation} other the operation to compare with\r\n   * @return {boolean} True if the operations are equal false otherwise\r\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n   */\r\n  equals(other: any) {\r\n    if (!(other instanceof Operation)) return false; // type test\r\n    return this.directive === other.directive && this.operand === other.operand;\r\n  };\r\n};\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/Latex.ts","/**\r\n * @fileoverview LaTeX style structures\r\n * This file is a part of TeXnous project.\r\n *\r\n * @copyright TeXnous project team (http://texnous.org) 2016\r\n * @license LGPL-3.0\r\n *\r\n * This library is free software; you can redistribute it and/or modify it under the terms of the\r\n * GNU Lesser General Public License as published by the Free Software Foundation; either version 3\r\n * of the License, or (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\r\n * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License along with this library;\r\n * if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\r\n * 02111-1307, USA.\r\n */\r\n\r\n/**@module */\r\n\r\n\r\nimport {isNumber, mustNotBeUndefined, testProperties} from './Utils'; // object property testing function\r\n\r\nimport {\r\n  Lexeme, Mode, modes, mustBeMode, mustBeOperationProperties, Operation, OperationProperties,\r\n  State\r\n} from './Latex';\r\n\r\n\r\nfunction isArray(x: any): x is any[] {\r\n  return x.constructor === Array\r\n}\r\n\r\nfunction mustBeArray(x: any): any[] {\r\n  if (!isArray(x))throw new Error();\r\n  return x;\r\n}\r\n\r\n/**\r\n * LaTeX style package properties\r\n * @interface PackageProperties\r\n * @property {(!Array.<!SymbolProperties>|undefined)} symbols - The symbols of the package in the priority descending order\r\n * @property {(!Array.<!CommandProperties>|undefined)} commands - The commands of the package in the priority descending order\r\n * @property {(!Array.<!EnvironmentProperties>|undefined)} environments - The environments of the package\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface PackageProperties {\r\n  symbols?: SymbolProperties[];\r\n  commands?: CommandProperties[];\r\n  environments?: EnvironmentProperties[];\r\n}\r\n\r\n/**\r\n * LaTeX style collection\r\n * @class\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport default class LatexStyle {\r\n  private environments_: { [name: string]: EnvironmentAndPackage[] };\r\n  private commands_: { [name: string]: CommandAndPackage[] };\r\n  private symbols_: { [name: string]: SymbolAndPackage[] };\r\n\r\n\r\n  /**\r\n   * Constructor\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  constructor() {\r\n    /**\r\n     * The symbols by the first symbol of the pattern in the priority increasing order\r\n     * @private {!Object.<string,!Array.<!Symbol>>}\r\n     * @name symbols_\r\n     */\r\n    this.symbols_ = {};\r\n    /**\r\n     * The commands by the name in the priority increasing order\r\n     * @private {!Object.<string,!Array.<!Command>>}\r\n     * @name commands_\r\n     */\r\n    this.commands_ = {};\r\n    /**\r\n     * The environments by the name in the priority increasing order\r\n     * @private {!Object.<string,!Array.<!Environment>>}\r\n     * @name environments_\r\n     */\r\n    this.environments_ = {};\r\n  };\r\n\r\n\r\n  /**\r\n   * Load a package with style definitions\r\n   * @param {string} packageName the name of the style package\r\n   * @param {PackageProperties} stylePackage the style package\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  loadPackage(packageName: string, stylePackage: PackageProperties) {\r\n    if (stylePackage.symbols !== undefined) { // if the symbol descriptions are defined\r\n      if (!(stylePackage.symbols instanceof Array))\r\n        throw new TypeError('\"stylePackage.symbols\" isn\\'t an Array');\r\n      // for all the symbol descriptions\r\n      for (let iSymbol = stylePackage.symbols.length - 1; iSymbol >= 0; --iSymbol) {\r\n        let symbol: Symbol = new Symbol(stylePackage.symbols[iSymbol]); // the symbol description\r\n        if (symbol.pattern) { // if the symbol has a pattern\r\n          let symbolPatternFirstChar = symbol.pattern[0]; // the first char of the pattern\r\n          // the symbols with the same pattern first char\r\n          if (!this.symbols_.hasOwnProperty(symbolPatternFirstChar))\r\n            this.symbols_[symbolPatternFirstChar] = [];\r\n          let symbols: SymbolAndPackage[] = this.symbols_[symbolPatternFirstChar];\r\n\r\n          symbols.push({symbol, packageName}); // store the symbol and the package name\r\n        }\r\n      }\r\n    }\r\n    if (stylePackage.commands !== undefined) { // if the command descriptions are defined\r\n      if (!(stylePackage.commands instanceof Array))\r\n        throw new TypeError('\"stylePackage.commands\" isn\\'t an Array');\r\n      // for all the command descriptions\r\n      for (let iCommand = stylePackage.commands.length - 1; iCommand >= 0; --iCommand) {\r\n        let command = new Command(stylePackage.commands[iCommand]); // the command description\r\n        if (command.name) { // if the command has a name\r\n          // the commands with the same name\r\n          (this.commands_[command.name] || (this.commands_[command.name] = []))\r\n            .push({command, packageName}); // store the command and the package name\r\n        }\r\n      }\r\n    }\r\n    if (stylePackage.environments !== undefined) { // if the environment descriptions are defined\r\n      if (!(stylePackage.environments instanceof Array))\r\n        throw new TypeError(`\"stylePackage.environments\" isn't an Array`);\r\n      // for all the environment descriptions\r\n      for (let iEnvironment = stylePackage.environments.length - 1; iEnvironment >= 0;\r\n           --iEnvironment) {\r\n        // the environment description\r\n        let environment: Environment = new Environment(stylePackage.environments[iEnvironment]);\r\n        const envName: string = environment.name;\r\n        if (envName) { // if the environment has a name\r\n          // the environments with the same name\r\n          let storedEnv = this.environments_[envName];\r\n          if (storedEnv === undefined) {\r\n            storedEnv = [];\r\n            this.environments_[envName] = storedEnv;\r\n          }\r\n          storedEnv.push({environment, packageName}); // store the environment and the package name\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Unload a package with style definitions\r\n   * @param {string} packageName the name of the style package\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  unloadPackage(packageName: string) {\r\n    // for all the symbol pattern first chars\r\n    for (let symbolPatternFirstChar in this.symbols_)\r\n      if (this.symbols_.hasOwnProperty(symbolPatternFirstChar)) {\r\n        // the filtered symbols with the same pattern first char\r\n        let filteredSymbols = mustBeArray(this.symbols_[symbolPatternFirstChar]).filter(styleItem => {\r\n          return styleItem.packageName !== packageName;\r\n        });\r\n        // if there are still some symbols with the same pattern first char\r\n        if (filteredSymbols.length) {\r\n          // store the filtered symbol descriptions\r\n          this.symbols_[symbolPatternFirstChar] = filteredSymbols;\r\n        } else { // if there are no the symbols with the same pattern first char\r\n          delete this.symbols_[symbolPatternFirstChar]; // delete the key-value pair\r\n        }\r\n      }\r\n    // for all the command names\r\n    for (let commandName in this.commands_) if (this.commands_.hasOwnProperty(commandName)) {\r\n      // the filtered commands with the same name\r\n      let filteredCommands = mustBeArray(this.commands_[commandName]).filter(styleItem => {\r\n        return styleItem.packageName !== packageName;\r\n      });\r\n      if (filteredCommands.length) { // if there are still some commands with the same name\r\n        this.commands_[commandName] = filteredCommands; // store the filtered command descriptions\r\n      } else { // if there are no the commands with the same name\r\n        delete this.commands_[commandName]; // delete the key-value pair\r\n      }\r\n    }\r\n    // for all the environment names\r\n    for (let environmentName in this.environments_)\r\n      if (this.environments_.hasOwnProperty(environmentName)) {\r\n        // the filtered environments with the same name\r\n        let filteredEnvironments = mustBeArray(this.environments_[environmentName]).filter(styleItem => {\r\n          return styleItem.packageName !== packageName;\r\n        });\r\n        // if there are still some environments with the same name\r\n        if (filteredEnvironments.length) {\r\n          // store the filtered environment descriptions\r\n          this.environments_[environmentName] = filteredEnvironments;\r\n        } else { // if there are no the environments with the same name\r\n          delete this.environments_[environmentName]; // delete the key-value pair\r\n        }\r\n      }\r\n  };\r\n\r\n\r\n  /**\r\n   * Get symbols\r\n   * @param {!State} state the state that the symbols must match to\r\n   * @param {string} patternFirstChar the first char of the symbol parameter pattern\r\n   * @return {!Array.<!Symbol>} the list of symbols in the priority descending order\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  symbols(state: State, patternFirstChar: string) {\r\n    if (!(state instanceof State))\r\n      throw new SyntaxError('\"state\" isn\\'t a State instance');\r\n    // all the symbols with the defined first pattern char\r\n    let symbols = this.symbols_[patternFirstChar];\r\n    if (symbols === undefined) return []; // return empty list if there are no such symbols\r\n    let filteredSymbols = []; // the list of the symbols matching to the state\r\n    for (let iSymbol = mustBeArray(symbols).length - 1; iSymbol >= 0; --iSymbol) { // for all the symbols\r\n      let symbol = symbols[iSymbol].symbol; // the symbol\r\n      // store the symbol if it matches to the state\r\n      //noinspection JSUnresolvedFunction\r\n      if (state.test(symbol.modes)) filteredSymbols.push(symbol);\r\n    }\r\n    return filteredSymbols;\r\n  };\r\n\r\n\r\n  /**\r\n   * Get commands\r\n   * @param {!State} state the state that the commands must match to\r\n   * @param {!string} name the name of the command\r\n   * @return {Array.<Command>} the list of commands in the priority descending order\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  commands(state: State, name: string): Command[] {\r\n    if (!(state instanceof State))\r\n      throw new SyntaxError('\"state\" isn\\'t a State instance');\r\n    let commands = this.commands_[name]; // all the commands with the defined name\r\n    if (!commands) return []; // return empty list if there are no such commands\r\n    let filteredCommands = []; // the list of the commands matching to the state\r\n    for (let iCommand = mustBeArray(commands).length - 1; iCommand >= 0; --iCommand) { // for all the commands\r\n      let command = commands[iCommand].command; // the command\r\n      // store the command if it matches to the state\r\n      //noinspection JSUnresolvedFunction\r\n      if (state.test(command.modes)) filteredCommands.push(command);\r\n    }\r\n    return filteredCommands;\r\n  };\r\n\r\n\r\n  /**\r\n   * Get environments\r\n   * @param {!State} state the state that the environments must match to\r\n   * @param {!string} name the name of the environment\r\n   * @return {Array.<Environment>} the list of environments in the priority descending order\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  environments(state: State, name: string): EnvironmentAndPackage[] {\r\n    if (!(state instanceof State)) throw new SyntaxError('state isn\\'t State instance');\r\n    let environments: EnvironmentAndPackage[] = this.environments_[name]; // all the environments with the defined name\r\n    if (!environments) return []; // return empty list if there are no such environments\r\n\r\n    // store the environment if it matches to the state\r\n    return mustBeArray(environments)\r\n      .filter(env => state.test(env.modes));\r\n  };\r\n};\r\n\r\n\r\n/**\r\n * LaTeX style item properties\r\n * @interface ItemProperties\r\n * @property {(Lexeme|undefined)} lexeme - The logical lexeme\r\n * @property {(!Object.<Mode, boolean>|undefined)} modes -\r\n *           The modes where the item is defined or not\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface ItemProperties {\r\n  lexeme?: Lexeme;\r\n  modes?: { [mode: string]: boolean };\r\n}\r\n\r\n\r\n/**\r\n * LaTeX style item encapsulation\r\n * @class\r\n * @property {(?Lexeme)} lexeme - The logical lexeme\r\n * @property {!Object.<Mode, boolean>} modes - The modes where the item is defined or not\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class Item {\r\n  lexeme?: Lexeme;\r\n  modes: { [mode: string]: boolean };\r\n\r\n  /**\r\n   * Constructor.\r\n   * @param {!ItemProperties=} opt_initialProperties the initial property values\r\n   */\r\n  constructor(opt_initialProperties: ItemProperties = {}) {\r\n    // do nothing if there are no initial properties\r\n    if (opt_initialProperties === undefined) return;\r\n    if (!(opt_initialProperties instanceof Object))\r\n      throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\r\n    switch (opt_initialProperties.lexeme) {\r\n      case undefined:\r\n        break; // do nothing if no lexeme defined\r\n      case null:\r\n        break; // do nothing if the default lexeme defined\r\n      default:\r\n        let lexeme = Lexeme[opt_initialProperties.lexeme]; // verify the lexeme\r\n        if (lexeme === undefined)\r\n          throw new TypeError('\"initialProperties.lexeme\" isn\\'t a Lexeme option');\r\n        Object.defineProperty(this, 'lexeme', {value: lexeme});\r\n    }\r\n    if (opt_initialProperties.modes !== undefined) {// if the mode states are set\r\n      if (!(opt_initialProperties.modes instanceof Object))\r\n        throw new TypeError('\"initialProperties.modes\" isn\\'t an Object instance');\r\n      Object.defineProperty(this, 'modes', {value: {}}); // create the mode state storage\r\n      for (let modeKey in opt_initialProperties.modes) { // for all the given modes // TODO better loop\r\n        let mode: Mode = mustBeMode(modeKey); // verify the mode key\r\n        if (mode === undefined) // if the mode is unknown\r\n          throw new TypeError('\"initialProperties.modes[' + modeKey +\r\n            ']\" isn\\'t a Mode option');\r\n        // store the mode state\r\n        //noinspection JSUnfilteredForInLoop\r\n        Object.defineProperty(this.modes, mode, {\r\n          value: opt_initialProperties.modes[modeKey],\r\n          enumerable: true\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Compare this item with the other one\r\n   * @param {?Item} other the item to compare with\r\n   * @return {boolean} true if the items are equal, false otherwise\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  equals(other: any) {\r\n    if (!(other instanceof Item)) return false;\r\n    return this.lexeme === other.lexeme &&\r\n      testProperties(this.modes, other.modes, modes, false);\r\n  }\r\n}\r\n;\r\nObject.defineProperties(Item.prototype, { // default property values\r\n  lexeme: {value: undefined, enumerable: true}, // no lexeme by default\r\n  modes: {value: {}, enumerable: true} // no mode mask by default\r\n});\r\n\r\n\r\n/**\r\n * LaTeX symbol or command parameter properties\r\n * @interface ParameterProperties\r\n * @extends ItemProperties\r\n * @property {(!Array.<!Operation|!OperationProperties>|undefined)} operations -\r\n *           The LaTeX operations that are performed before the parameter\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface ParameterProperties extends ItemProperties {\r\n  operations?: (Operation | OperationProperties)[];\r\n}\r\n\r\nexport function isParameterProperties(ignored: any): ignored is ParameterProperties {\r\n  return true; // todo fields are all optional\r\n}\r\n\r\nexport function mustBeParameterProperties(x: any): ParameterProperties {\r\n  if (!isParameterProperties) throw new Error();\r\n  return x;\r\n}\r\n\r\n/**\r\n * LaTeX symbol or command parameter encapsulation\r\n * @class\r\n * @extends Item\r\n * @property {!Array.<!Operation>} operations -\r\n *           The LaTeX operations that are performed before this parameter\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class Parameter extends Item {\r\n  //noinspection JSMismatchedCollectionQueryUpdate TODO\r\n  private operations_: Operation[];\r\n\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!ParameterProperties=} opt_initialProperties the initial property values\r\n   */\r\n  constructor(opt_initialProperties: ParameterProperties = {}) {\r\n    super(opt_initialProperties); // the superclass constructor\r\n    // do nothing if there are no initial properties\r\n    if (opt_initialProperties === undefined) return;\r\n    if (opt_initialProperties.operations !== undefined) { // if the operation list is set\r\n      if (!(opt_initialProperties.operations instanceof Array))\r\n        throw new TypeError('\"initialProperties.operations\" isn\\'t an Array instance');\r\n      Object.defineProperty(this, 'operations_', { // generate and store the operations list\r\n        value: opt_initialProperties.operations.map(operation => new Operation(operation))\r\n      });\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the LaTeX operations that are performed before this parameter\r\n   * @return {!Array.<!Operation>} the operation list\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get operations(): Operation[] {\r\n    return this.operations_.slice()\r\n  }\r\n\r\n\r\n  /**\r\n   * Compare this parameter with the other one\r\n   * @param {?Parameter} other the parameter to compare with\r\n   * @return {boolean} true if the parameters are equal, false otherwise\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  equals(other: any) {\r\n    if (!(other instanceof Parameter)) return false; // type test\r\n    if (!super.equals(other)) return false; // superclass test\r\n\r\n    if (this.operations_.length !== other.operations_.length) return false;\r\n    // test all the operations\r\n\r\n    return this.operations_.every((operation, iOperation) =>\r\n      operation.equals(other.operations_[iOperation]));\r\n  }\r\n}\r\n;\r\nObject.defineProperties(Parameter.prototype, { // make getters and setters enumerable\r\n  operations: {enumerable: true}\r\n});\r\nObject.defineProperties(Parameter.prototype, { // default property values\r\n  operations_: {value: [], enumerable: false} // empty operation list by default\r\n});\r\n\r\n\r\n/**\r\n * LaTeX symbol properties\r\n * @interface SymbolProperties\r\n * @extends ItemProperties\r\n * @property {(!Array.<!Operation|!OperationProperties>|undefined)} operations - The LaTeX operations that\r\n * @property {(!Array.<!Parameter|!ParameterProperties>|undefined)} parameters - The parameters description list\r\n * @property {(string|undefined)} pattern - The LaTeX input pattern\r\n * @property {(string|undefined)} html - The HTML output pattern\r\n * are performed after the symbol\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface SymbolProperties extends ItemProperties {\r\n  operations?: (Operation | OperationProperties)[];\r\n  parameters?: (Parameter | ParameterProperties)[];\r\n  pattern?: string;\r\n  html?: string;\r\n}\r\n\r\nexport interface SymbolAndPackage {\r\n  symbol: Symbol;\r\n  packageName: string;\r\n}\r\n\r\n/**\r\n * LaTeX symbol encapsulation\r\n * @class\r\n * @extends Item\r\n * @property {!Array.<!Operation>} operations -\r\n *           The LaTeX operations that are performed after this symbol\r\n * @property {!Array.<!Parameter>} parameters - The parameters description list\r\n * @property {!Array.<undefined|string|number>} patternComponents - The LaTeX input pattern components\r\n * @property {string} pattern - The LaTeX input pattern\r\n * @property {string} html - The HTML output pattern\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class Symbol extends Item {\r\n  //noinspection JSMismatchedCollectionQueryUpdate // TODO\r\n  private operations_: Operation[];\r\n  //noinspection JSMismatchedCollectionQueryUpdate // TODO\r\n  private parameters_: Parameter[];\r\n  //noinspection JSMismatchedCollectionQueryUpdate // TODO\r\n  private patternComponents_: (undefined | string | number)[];\r\n\r\n  html: string;\r\n\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!SymbolProperties=} opt_initialProperties the initial property values\r\n   */\r\n  constructor(opt_initialProperties: SymbolProperties = {}) {\r\n    super(opt_initialProperties); // the superclass constructor\r\n    // do nothing if there are no initial properties\r\n    if (opt_initialProperties === undefined) return;\r\n    if (opt_initialProperties.operations !== undefined) { // if the operation list is set\r\n      if (!(opt_initialProperties.operations instanceof Array))\r\n        throw new TypeError('\"initialProperties.operations\" isn\\'t an Array instance');\r\n      Object.defineProperty(this, 'operations_', { // generate and store the operations list\r\n        value: opt_initialProperties.operations.map(operation => new Operation(mustBeOperationProperties(operation)))\r\n      });\r\n    }\r\n    if (opt_initialProperties.parameters !== undefined) { // if the parameters list is set\r\n      if (!(opt_initialProperties.parameters instanceof Array))\r\n        throw new TypeError('\"initialProperties.parameters\" isn\\'t an Array instance');\r\n      // generate and store the parameters list\r\n      this.parameters_ = opt_initialProperties.parameters.map(parameter => new Parameter(mustBeParameterProperties(parameter)));\r\n    }\r\n    if (opt_initialProperties.pattern !== undefined) { // if the LaTeX pattern is set\r\n      if (typeof opt_initialProperties.pattern !== 'string')\r\n        throw new TypeError('\"initialProperties.pattern\" isn\\'t a string');\r\n      // try to parse the pattern\r\n      const patternComponents = opt_initialProperties.pattern.match(/([ \\t]+|#\\d+|[^ \\t#]+)/g);\r\n      if (!!patternComponents) { // if there is a non-trivial pattern\r\n\r\n        // store the pattern components\r\n        this.patternComponents_ = patternComponents.map((patternPart: string): string | undefined | number => {\r\n          switch (patternPart[0]) {\r\n            case ' ':\r\n            case '\\t': // if a space part\r\n              return undefined; // undefined is a mark for spaces\r\n            case '#': // if a parameter part\r\n              let parameterIndex = Number(patternPart.substring(1)) - 1; // the index of a parameter\r\n              if (!this.parameters_[parameterIndex])\r\n                throw new TypeError(\r\n                  '\"initialProperties.pattern\" contains the incorrect parameter number ' +\r\n                  patternPart.substring(1)\r\n                );\r\n              return parameterIndex;\r\n            default: // raw pattern part\r\n              return patternPart;\r\n          }\r\n        });\r\n      }\r\n    }\r\n    if (opt_initialProperties.html !== undefined) { // if the LaTeX pattern is set\r\n      if (typeof opt_initialProperties.html !== 'string')\r\n        throw new TypeError('\"initialProperties.html\" isn\\'t a string');\r\n      // store the pattern\r\n      Object.defineProperty(this, 'html', {value: opt_initialProperties.html, enumerable: true});\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Get the LaTeX operations that are performed after this symbol\r\n   * @return {!Array.<!Operation>} the operation list\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get operations(): Operation[] {\r\n    return this.operations_.slice()\r\n  }\r\n\r\n  /**\r\n   * Get the parameters description list\r\n   * @return {!Array.<!Latex.Parameter>} the parameter list\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get parameters(): Parameter[] {\r\n    return this.parameters_.slice()\r\n  }\r\n\r\n  /**\r\n   * Get the parameter description\r\n   * @param {number} parameterIndex the index of the parameter\r\n   * @return {?Latex.Parameter} the parameter or undefined if there is no parameter with such an index\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  parameter(parameterIndex: number): Parameter | undefined {\r\n    return this.parameters_[parameterIndex] || undefined\r\n  }\r\n\r\n  /**\r\n   * Get the pattern components\r\n   * @return {!Array.<!Latex.Parameter>} the pattern component list\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get patternComponents(): any[] {\r\n    return mustNotBeUndefined(this.patternComponents_.slice())\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the pattern\r\n   * @return {string} the LaTeX input pattern\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get pattern() {\r\n    return this.patternComponents_.map(patternComponent => {\r\n      if (isNumber(patternComponent)) {\r\n        return '#' + (patternComponent + 1);\r\n      }\r\n      switch (typeof patternComponent) {\r\n        case 'string':\r\n          return patternComponent;\r\n        default:\r\n          return ' ';\r\n      }\r\n    }).join('');\r\n  }\r\n\r\n  /**\r\n   * Compare this symbol with the other one\r\n   * @param {?Symbol} other the symbol to compare with\r\n   * @return {boolean} true if the symbols are equal, false otherwise\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  equals(other: any): boolean {\r\n    if (!(other instanceof Symbol)) return false; // type test\r\n    if (!super.equals(other)) return false; // superclass test\r\n\r\n    if (this.operations_.length !== other.operations_.length) return false;\r\n    // test all the operations\r\n\r\n    if (!this.operations_.every((operation, iOperation) =>\r\n        operation.equals(other.operations_[iOperation])))\r\n      return false;\r\n\r\n    if (this.parameters_.length !== other.parameters_.length) return false;\r\n    // test all the parameters\r\n\r\n    if (!this.parameters_.every((parameter, iParameter) =>\r\n        parameter.equals(other.parameters_[iParameter])))\r\n      return false;\r\n    return this.html === other.html;\r\n  }\r\n}\r\n;\r\nObject.defineProperties(Symbol.prototype, { // make getters and setters enumerable\r\n  operations: {enumerable: true},\r\n  parameters: {enumerable: true},\r\n  patternComponents: {enumerable: true},\r\n  pattern: {enumerable: true}\r\n});\r\n\r\nObject.defineProperties(Symbol.prototype, { // default property values\r\n  operations_: {value: [], enumerable: false, writable: true}, // empty operation list\r\n  parameters_: {value: [], enumerable: false, writable: true}, // empty parameter list\r\n  patternComponents_: {value: [], enumerable: false, writable: true}, // empty pattern\r\n  html: {value: '', enumerable: true, writable: true} // empty HTML pattern\r\n});\r\n\r\n\r\n/**\r\n * LaTeX command properties\r\n * @interface CommandProperties\r\n * @extends SymbolProperties\r\n * @property {(string|undefined)} name - The command name (a sequence of letters and optional star)\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface CommandProperties extends SymbolProperties {\r\n  name?: string;\r\n}\r\n\r\nexport interface CommandAndPackage {\r\n  command: Command;\r\n  packageName: string;\r\n}\r\n\r\n/**\r\n * LaTeX command encapsulation\r\n * @class\r\n * @extends Symbol\r\n * @property {string} name - The command name (a sequence of letters and optional star)\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class Command extends Symbol {\r\n  name: string;\r\n\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!CommandProperties=} opt_initialProperties the initial property values\r\n   */\r\n  constructor(opt_initialProperties: CommandProperties = {}) {\r\n    super(opt_initialProperties); // the superclass constructor\r\n    // do nothing if there are no initial properties\r\n    if (opt_initialProperties === undefined) return;\r\n    if (opt_initialProperties.name !== undefined) { // if the name is set\r\n      if (typeof opt_initialProperties.name !== 'string')\r\n        throw new TypeError('\"initialProperties.name\" isn\\'t a string');\r\n      // store the name\r\n      Object.defineProperty(this, 'name', {value: opt_initialProperties.name});\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Compare this command with the other one\r\n   * @param {?Command} other the command to compare with\r\n   * @return {boolean} true if the commands are equal, false otherwise\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  equals(other: any) {\r\n    if (!(other instanceof Command)) return false; // type test\r\n    if (!super.equals(other)) return false; // superclass test\r\n    return this.name === other.name;\r\n  }\r\n}\r\n;\r\nObject.defineProperties(Command.prototype, { // default property values\r\n  name: {value: '', enumerable: true} // empty name\r\n});\r\nexport function isCommand(c: any): c is Command {\r\n  return c instanceof Command;\r\n}\r\nexport function mustBeCommand(c: any): Command {\r\n  if (!isCommand(c)) throw new Error();\r\n  return c;\r\n}\r\n\r\n\r\n/**\r\n * LaTeX command properties\r\n * @interface EnvironmentProperties\r\n * @extends ItemProperties\r\n * @property {(string|undefined)} name - The command name (a sequence of letters and optional star)\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface EnvironmentProperties extends ItemProperties {\r\n  name?: string;\r\n}\r\n\r\nexport interface EnvironmentAndPackage {\r\n  environment: Environment;\r\n  packageName?: string;\r\n}\r\n\r\n/**\r\n * LaTeX environment encapsulation\r\n * @class\r\n * @extends Item\r\n * @property {string} name - The environment name (a sequence of letters and optional star)\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class Environment extends Item {\r\n  name: string;\r\n\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!EnvironmentProperties=} opt_initialProperties the initial property values\r\n   */\r\n  constructor(opt_initialProperties: EnvironmentProperties = {}) {\r\n    super(opt_initialProperties); // the superclass constructor\r\n    // do nothing if there are no initial properties\r\n    if (opt_initialProperties === undefined) return;\r\n    if (opt_initialProperties.name !== undefined) { // if the name is set\r\n      if (typeof opt_initialProperties.name !== 'string')\r\n        throw new TypeError('\"initialProperties.name\" isn\\'t a string');\r\n      // store the name\r\n      Object.defineProperty(this, 'name', {value: opt_initialProperties.name});\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Compare this environment with the other one\r\n   * @param {?Environment} other the environment to compare with\r\n   * @return {boolean} true if the environments are equal, false otherwise\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  equals(other: any) {\r\n    if (!(other instanceof Environment)) return false; // type test\r\n    if (!super.equals(other)) return false; // superclass test\r\n    return this.name === other.name;\r\n  }\r\n}\r\n;\r\nObject.defineProperties(Environment.prototype, { // default property values\r\n  name: {value: '', enumerable: true} // empty name\r\n});\r\nexport function isEnvironment(x: any): x is Environment {\r\n  return x instanceof Environment;\r\n}\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/LatexStyle.ts","/**\r\n * @fileoverview LaTeX syntax tree structure elements\r\n * This file is a part of TeXnous project.\r\n *\r\n * @copyright TeXnous project team (http://texnous.org) 2016\r\n * @license LGPL-3.0\r\n *\r\n * This library is free software; you can redistribute it and/or modify it under the terms of the\r\n * GNU Lesser General Public License as published by the Free Software Foundation; either version 3\r\n * of the License, or (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\r\n * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License along with this library;\r\n * if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\r\n * 02111-1307, USA.\r\n */\r\n\r\n/** @module */\r\n\r\n/** @external LatexStyle*/\r\nimport {Command, Environment, isEnvironment, mustBeCommand, Parameter, Symbol} from './LatexStyle'; // LaTeX style structures\r\n/** @external SyntaxTree */\r\nimport {SyntaxTree, Node} from './SyntaxTree';\r\nimport {Lexeme} from \"./Latex\";\r\nimport {mustNotBeUndefined} from \"./Utils\";\r\n\r\n\r\n/**\r\n * LaTeX syntax tree structure\r\n * @class\r\n * @extends SyntaxTree\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport default class extends SyntaxTree {\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!Token} rootToken the root token (must have no parent and no tree)\r\n   * @param {string} source the sources text that has this syntax tree\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  constructor(rootToken: Token, source: string) {\r\n    if (!(rootToken instanceof Token))\r\n      throw new TypeError('\"rootToken\" isn\\'t a Token instance');\r\n    super(rootToken, source); // the superclass constructor\r\n  }\r\n};\r\n\r\n\r\n\r\n/**\r\n * LaTeX syntax tree token base properties\r\n * @interface TokenProperties\r\n * @property {(?Token|undefined)} parentToken - The parent token or undefined if there is no parent\r\n * @property {(!Array.<Token>|undefined)} childTokens - The list of the child tokens\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface TokenProperties {\r\n  parentToken?: Token;\r\n  childTokens?: Token[];\r\n}\r\n\r\n\r\n/**\r\n * LaTeX syntax tree token base structure\r\n * @class\r\n * @extends SyntaxTree.Node\r\n * @property {(Lexeme|undefined)} lexeme - The logical lexeme of the token\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class Token extends Node {\r\n  lexeme?: Lexeme;\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!TokenProperties=} opt_initialProperties the initial property values\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  constructor(opt_initialProperties: TokenProperties = {}) {\r\n    if (opt_initialProperties === undefined) { // if the initial properties are not set\r\n      super(); // superclass constructor\r\n    } else if (opt_initialProperties instanceof Object) { // if the initial properties are set\r\n      // superclass constructor\r\n      // superclass initial properties\r\n      let superInitialProperties = Object.create(opt_initialProperties);\r\n      superInitialProperties.parentNode = opt_initialProperties.parentToken;\r\n      superInitialProperties.childNodes = opt_initialProperties.childTokens;\r\n      super(superInitialProperties);\r\n    } else { // if the initial properties are in unsupported type\r\n      throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the string representation of this node\r\n   * @param {boolean=false} skipNodeClass\r\n   *        true to not include the node class name into the output, false otherwise\r\n   * @return {string} the sources string\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  toString(skipNodeClass: boolean = false) {\r\n    return skipNodeClass ? super.toString(true) : 'Token{' + super.toString(true) + '}';\r\n  }\r\n};\r\nObject.defineProperties(Token.prototype, { // default properties\r\n  lexeme: { value: undefined, enumerable: true }, // no lexeme\r\n  parentNodeClass_: { value: Token } // parent node must be an EnvironmentToken instance\r\n});\r\n\r\n\r\n\r\n/**\r\n * LaTeX symbol token properties\r\n * @interface SymbolTokenProperties\r\n * @extends TokenProperties\r\n * @property {!Symbol|undefined} symbol - The LaTeX symbol or undefined if the symbol is unrecognized\r\n * @property {string|undefined} pattern - The pattern that corresponds to the unrecognized symbol\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface SymbolTokenProperties extends TokenProperties {\r\n  symbol?: Symbol;\r\n  pattern?: string;\r\n}\r\n\r\n\r\n/**\r\n * LaTeX symbol token structure\r\n * @class\r\n * @extends Token\r\n * @property {?Symbol} symbol - The corresponding LaTeX symbol or undefined if the symbol is unrecognized\r\n * @property {string} pattern - The symbol LaTeX pattern\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class SymbolToken extends Token {\r\n  symbol?: Symbol;\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!SymbolTokenProperties} initialProperties the initial property values\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  constructor(initialProperties: SymbolTokenProperties) {\r\n    if (!(initialProperties instanceof Object))\r\n      throw new TypeError ('\"initialProperties\" isn\\'t an Object instance');\r\n    super(initialProperties); // the superclass constructor\r\n    if (initialProperties.symbol) { // if the symbol is defined\r\n      if (!(initialProperties.symbol instanceof Symbol))\r\n        throw new TypeError('\"initialProperties.symbol\" isn\\'t a Symbol instance');\r\n      // store the symbol\r\n      Object.defineProperty(this, 'symbol', {value: initialProperties.symbol, enumerable: true});\r\n    } else { // if the symbol isn't defined\r\n      if (typeof initialProperties.pattern !== 'string')\r\n        throw new TypeError('\"initialProperties.pattern\" isn\\'t a string');\r\n      // store the unrecognized pattern\r\n      Object.defineProperty(this, 'pattern', { value: initialProperties.pattern });\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the logical lexeme\r\n   * @return {(Lexeme|undefined)} the lexeme or undefined if the lexeme isn't defined\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get lexeme (): Lexeme | undefined {\r\n    \r\n    return this.symbol ? this.symbol.lexeme : undefined;\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the symbol LaTeX pattern\r\n   * @return {string} the symbol pattern\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get pattern (): string {\r\n    return mustNotBeUndefined(this.symbol).pattern;\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the string representation of this node\r\n   * @param {boolean=false} skipNodeClass\r\n   *        true to not include the node class name into the output, false otherwise\r\n   * @return {string} the sources string\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  toString(skipNodeClass: boolean = false) {\r\n    let source = '';\r\n    let iParameter = 0; // the parameter iterator\r\n    \r\n    let pattern = this.pattern; // LaTeX input pattern\r\n    // for all the pattern chars\r\n    for (\r\n      let nPatternChars = pattern.length, iPatternChar = 0;\r\n      iPatternChar < nPatternChars;\r\n      ++iPatternChar\r\n    ) {\r\n      let patternChar = pattern[iPatternChar]; // the pattern char\r\n      if (patternChar === '#') { // if a parameter place\r\n        ++iPatternChar; // go to the next pattern char\r\n        let parameterToken = this.childNode(iParameter++); // try to get the parameter token\r\n        source += parameterToken ? parameterToken.toString(true) : '??';\r\n      } else { // if the ordinary pattern char\r\n        source += patternChar;\r\n      }\r\n    }\r\n    return skipNodeClass ?\r\n      source :\r\n      'SymbolToken' + (this.symbol ? '' : '[?]') + '{' + source + '}';\r\n  }\r\n};\r\nObject.defineProperties(SymbolToken.prototype, { // default properties\r\n  symbol: { value: undefined, enumerable: true } // no symbol token\r\n});\r\nObject.defineProperties(SymbolToken.prototype, { // make getters and setters enumerable\r\n  pattern: { enumerable: true }\r\n});\r\n\r\n\r\n\r\n/**\r\n * LaTeX parameter token properties\r\n * @interface ParameterTokenProperties\r\n * @extends TokenProperties\r\n * @property {boolean} hasBrackets - True if the parameter is bounded by the logical brackets, false otherwise\r\n * @property {boolean} hasSpacePrefix - True if the parameter is prefixed by a space, false otherwise\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface ParameterTokenProperties extends TokenProperties {\r\n  hasBrackets: boolean;\r\n  hasSpacePrefix: boolean;\r\n}\r\n\r\n\r\n/**\r\n * LaTeX parameter token structure\r\n * @class\r\n * @extends Token\r\n * @property {boolean} hasBrackets -\r\n *           True if the parameter is bounded by the logical brackets, false otherwise\r\n * @property {boolean} hasSpacePrefix -\r\n *           True if the parameter is prefixed by a space, false otherwise\r\n * @property {?LatexStyle.Parameter} parameter - The corresponding LaTeX parameter\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class ParameterToken extends Token {\r\n  public parentNode: SymbolToken;\r\n\r\n  private hasBrackets: boolean;\r\n  hasSpacePrefix: boolean;\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!ParameterTokenProperties} initialProperties the initial property values\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  constructor(initialProperties: ParameterTokenProperties) {\r\n    if (!(initialProperties instanceof Object))\r\n      throw new TypeError ('\"initialProperties\" isn\\'t an Object instance');\r\n    super(initialProperties); // the superclass constructor\r\n    if (!initialProperties.hasBrackets) // if there are no bounding brackets\r\n      // store this fact\r\n      Object.defineProperty(this, 'hasBrackets', { value: false, enumerable: true });\r\n    if (initialProperties.hasSpacePrefix) // if there is a space before\r\n      // store this fact\r\n      Object.defineProperty(this, 'hasSpacePrefix', { value: true, enumerable: true });\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the logical lexeme\r\n   * @return {(Lexeme|undefined)} the lexeme or undefined if the lexeme isn't defined\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get lexeme (): Lexeme | undefined {\r\n    if(this.parameter && this.parameter.lexeme) return this.parameter.lexeme;\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the corresponding LaTeX parameter description\r\n   * @return {?LatexStyle.Parameter}\r\n   *         the LaTeX parameter or undefined of there is parent symbol or such a parameter\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get parameter (): Parameter | undefined {\r\n    /** @type {?SymbolToken} */\r\n    let symbolToken = this.parentNode; // get the symbol token\r\n    let symbol = mustNotBeUndefined(symbolToken.symbol);\r\n    let parameterIndex = symbolToken.childIndex(this);\r\n    if(symbolToken !== undefined && parameterIndex !== undefined && parameterIndex >= 0)\r\n      return symbol.parameter(parameterIndex);\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the string representation of this node\r\n   * @param {boolean=false} skipNodeClass\r\n   *        true to not include the node class name into the output, false otherwise\r\n   * @return {string} the sources string\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  toString(skipNodeClass: boolean = false) {\r\n    let source = this.hasSpacePrefix ? ' ' : '';\r\n    source += this.hasBrackets ? '{' + super.toString(true) + '}' : super.toString(true);\r\n    return skipNodeClass ? source : 'ParameterToken{' + source + '}';\r\n  }\r\n};\r\nObject.defineProperties(ParameterToken.prototype, { // default properties\r\n  hasBrackets: { value: true, enumerable: true }, // there are bounding brackets\r\n  hasSpacePrefix: { value: false, enumerable: true }, // there is no space before\r\n  parentNodeClass_: { value: SymbolToken } // parent node must be a SymbolToken instance\r\n});\r\nObject.defineProperties(ParameterToken.prototype, { // make getters and setters enumerable\r\n  parameter: { enumerable: true }\r\n});\r\n\r\n\r\n\r\n/**\r\n * LaTeX command token properties\r\n * @interface CommandTokenProperties\r\n * @extends TokenProperties\r\n * @property {!LatexStyle.Command|undefined} command -\r\n *           The LaTeX command or undefined if the command is unrecognized\r\n * @property {string|undefined} name - The name that corresponds to the unrecognized command\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface CommandTokenProperties extends TokenProperties {\r\n  command?: Command;\r\n  name?: string;\r\n}\r\n\r\n\r\n/**\r\n * LaTeX command token structure\r\n * @class\r\n * @extends SymbolToken\r\n * @property {!LatexStyle.Command} command -\r\n *           The corresponding LaTeX command or undefined if the command is unrecognized\r\n * @property {string|undefined} name - The LaTeX command name\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class CommandToken extends SymbolToken {\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!CommandTokenProperties} initialProperties the initial property values\r\n   */\r\n  constructor(initialProperties: CommandTokenProperties) {\r\n    if (!(initialProperties instanceof Object))\r\n      throw new TypeError ('\"initialProperties\" isn\\'t an Object instance');\r\n    // copy the initial properties for the superclass\r\n    let superInitialProperties = Object.create(initialProperties);\r\n    if (initialProperties.command) { // if the command is defined\r\n      if (!(initialProperties.command instanceof Command))\r\n        throw new TypeError('\"initialProperties.command\" isn\\'t a LatexStyle.Command instance');\r\n      // the command is the symbol for the superclass\r\n      superInitialProperties.symbol = initialProperties.command;\r\n      super(superInitialProperties); // the superclass constructor\r\n    } else { // if the command isn't defined\r\n      if (typeof initialProperties.name !== 'string')\r\n        throw new TypeError('\"initialProperties.name\" isn\\'t a string');\r\n      superInitialProperties.pattern = '';\r\n      super(superInitialProperties); // the superclass constructor\r\n      // store the unrecognized name\r\n      Object.defineProperty(this, 'name', { value: initialProperties.name });\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the LaTeX command\r\n   * @return {!LatexStyle.Command} the command description\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get command (): Command { return mustBeCommand(this.symbol) }\r\n\r\n\r\n  /**\r\n   * Get the LaTeX command name\r\n   * @return {string} the command name\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get name (): string { return this.command.name }\r\n\r\n  /**\r\n   * Get the string representation of this node\r\n   * @param {boolean=false} skipNodeClass\r\n   *        true to not include the node class name into the output, false otherwise\r\n   * @return {string} the sources string\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  toString(skipNodeClass: boolean = false) {\r\n   let source = '\\\\' + this.name + super.toString(true);\r\n   return skipNodeClass ?\r\n     source :\r\n     'CommandToken' + (this.command ? '' : '[?]') + '{' + source + '}';\r\n  }\r\n};\r\n\r\nObject.defineProperties(CommandToken.prototype, { // make getters and setters enumerable\r\n  command: { enumerable: true },\r\n  name: {enumerable: true }\r\n});\r\n\r\nexport function isCommandToken(x: any): x is CommandToken {\r\n  return x && x instanceof CommandToken;\r\n}\r\n\r\n\r\n/**\r\n * LaTeX environment token properties\r\n * @interface EnvironmentTokenProperties\r\n * @extends TokenProperties\r\n * @property {!LatexStyle.Environment} environment - The LaTeX environment\r\n * @property\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\n\r\nexport interface EnvironmentTokenPropertiesWithEnvironment\r\n  extends EnvironmentTokenProperties {\r\n  environment: Environment;\r\n  name: undefined;\r\n}\r\n\r\nexport interface EnvironmentTokenPropertiesWithName\r\n  extends EnvironmentTokenProperties {\r\n  environment: undefined;\r\n  name: string;\r\n}\r\n\r\nexport interface EnvironmentTokenProperties\r\n  extends TokenProperties {\r\n  environment?: Environment;\r\n  name?: string;\r\n}\r\n\r\n/**\r\n * LaTeX environment token structure\r\n * @class\r\n * @extends Token\r\n * @property {!Environment} environment - The corresponding LaTeX environment\r\n * @property {?CommandToken} beginCommandToken -\r\n *           The environment begin command token or undefined is there is no such a token\r\n * @property {?CommandToken} endCommandToken -\r\n *           The environment end command token or undefined is there is no such a token\r\n * @property {?EnvironmentBodyToken} bodyToken -\r\n *           The environment body token or undefined is there is no such a token\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class EnvironmentToken extends Token {\r\n  environment: Environment;\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!EnvironmentTokenProperties} initialProperties the initial property values\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  constructor(initialProperties: EnvironmentTokenProperties) {\r\n    if (!(initialProperties instanceof Object))\r\n      throw new TypeError ('\"initialProperties\" isn\\'t an Object instance');\r\n    super(initialProperties); // the superclass constructor\r\n    if (!(initialProperties.environment instanceof Environment))\r\n      throw new TypeError(\r\n        '\"initialProperties.environment\" isn\\'t a LatexStyle.Environment instance');\r\n    // store the environment\r\n    Object.defineProperty(this, 'environment', {\r\n      value: initialProperties.environment,\r\n      enumerable: true\r\n    });\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the logical lexeme\r\n   * @return {(Lexeme|undefined)} the lexeme or undefined if the lexeme isn't defined\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get lexeme () { return this.environment.lexeme }\r\n\r\n\r\n  /**\r\n   * Get the begin command token\r\n   * @return {?CommandToken} the command token or undefined if there is no begin command\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get beginCommandToken () {\r\n    let beginCommandToken = this.childNode(0);\r\n    return beginCommandToken instanceof CommandToken ? beginCommandToken : undefined;\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the end command token\r\n   * @return {?CommandToken} the command token or undefined if there is no end command\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get endCommandToken () {\r\n    let endCommandToken = this.childNode(2);\r\n    return endCommandToken instanceof CommandToken ? endCommandToken : undefined;\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Get the environment body token\r\n   * @return {?EnvironmentBodyToken} the body or undefined if there is no body\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get bodyToken () {\r\n    let bodyToken = this.childNode(1);\r\n    return bodyToken instanceof EnvironmentBodyToken ? bodyToken : undefined;\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the string representation of this node\r\n   * @param {boolean=false} skipNodeClass\r\n   *        true to not include the node class name into the output, false otherwise\r\n   * @return {string} the sources string\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  toString(skipNodeClass:boolean=false) {\r\n    let beginCommandToken = this.beginCommandToken; // the begin command token\r\n    let endCommandToken = this.endCommandToken; // the end command token\r\n    let bodyToken = this.bodyToken; // the environment body token\r\n    let source = '\\\\begin{' + this.environment.name + '}';\r\n    source += beginCommandToken ?\r\n      SymbolToken.prototype.toString.call(beginCommandToken, true) :\r\n      '??';\r\n    source += bodyToken ? bodyToken.toString(true) : '??';\r\n    source += '\\\\end{' + this.environment.name + '}';\r\n    source += endCommandToken ? SymbolToken.prototype.toString.call(endCommandToken, true) : '??';\r\n    return skipNodeClass ? source : 'EnvironmentToken{' + source + '}';\r\n  }\r\n};\r\nObject.defineProperties(EnvironmentToken.prototype, { // make getters and setters enumerable\r\n  beginToken: { enumerable: true },\r\n  endToken: { enumerable: true }\r\n});\r\n\r\nexport function mustBeEnvironmentToken(x: any): EnvironmentToken {\r\n  if(!isEnvironmentToken(x)) throw new Error();\r\n  return x;\r\n}\r\n\r\nexport function isEnvironmentToken(x: any): x is EnvironmentToken {\r\n  return x instanceof EnvironmentToken;\r\n}\r\n\r\n\r\nfunction getBeginCommandToken(x: any): CommandToken | undefined {\r\n  if(isCommandToken(x.beginCommandToken))\r\n    return x.beginCommandToken;\r\n}\r\n\r\nfunction getEndCommandToken(x: any): CommandToken | undefined {\r\n  if(isCommandToken(x.endCommandToken))\r\n    return x.endCommandToken;\r\n}\r\n\r\nfunction getEnvironment(x: any): Environment | undefined {\r\n  if(x.environment && isEnvironment(x.environment))\r\n    return x.environment;\r\n}\r\n\r\n/**\r\n * LaTeX environment body token structure\r\n * @class\r\n * @extends Token\r\n * @property {?LatexStyle.Environment} environment -\r\n *           The LaTeX environment or undefined if there is no parent environment\r\n * @property {?EnvironmentToken} environmentToken - The parent environment token\r\n * @property {?CommandToken} beginCommandToken -\r\n *           The environment begin command token or undefined is there is no such a token\r\n * @property {?CommandToken} endCommandToken -\r\n *           The environment end command token or undefined is there is no such a token\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class EnvironmentBodyToken extends Token {\r\n\r\n  /**\r\n   * Get the LaTeX environment\r\n   * @return {?LatexStyle.Environment} the environment or undefined if there is no parent environment\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get environment (): Environment | undefined { return this.parentNode && getEnvironment(this.parentNode) }\r\n\r\n\r\n\r\n  //noinspection JSUnusedGlobalSymbols\r\n  /**\r\n   * Get the parent environment token\r\n   * @return {?EnvironmentToken} the environment or undefined if there is no parent environment\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get environmentToken (): EnvironmentToken | undefined { return this.parentNode && mustBeEnvironmentToken(this.parentNode); }\r\n\r\n\r\n\r\n  /**\r\n   * Get the environment begin command token\r\n   * @return {?CommandToken} the command token or undefined if there is no begin command\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get beginCommandToken () { return this.parentNode && getBeginCommandToken(this.parentNode) }\r\n\r\n\r\n\r\n  /**\r\n   * Get the environment end command token\r\n   * @return {(CommandToken|undefined)} the command token or undefined if there is no end command\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get endCommandToken () { return this.parentNode && getEndCommandToken(this.parentNode) }\r\n\r\n\r\n  /**\r\n   * Get the string representation of this node\r\n   * @param {boolean=false} skipNodeClass\r\n   *        true to not include the node class name into the output, false otherwise\r\n   * @return {string} the sources string\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  toString(skipNodeClass: boolean = false) {\r\n    return skipNodeClass ?\r\n      super.toString(true) :\r\n      'EnvironmentBodyToken{' + super.toString(true) + '}';\r\n  }\r\n};\r\nObject.defineProperties(EnvironmentBodyToken.prototype, { // default properties\r\n  parentNodeClass_: { value: EnvironmentToken } // parent node must be an EnvironmentToken instance\r\n});\r\n\r\n\r\n\r\n/**\r\n * LaTeX space token properties\r\n * @interface SpaceTokenProperties\r\n * @extends TokenProperties\r\n * @property {number|undefined} lineBreakCount - The number of line breaks\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface SpaceTokenProperties\r\n  extends TokenProperties {\r\n  lineBreakCount?: number;\r\n}\r\n\r\n/**\r\n * LaTeX space token structure\r\n * @class\r\n * @extends Token\r\n * @property {number} lineBreakCount - The number of line breaks\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class SpaceToken extends Token {\r\n  lineBreakCount: number;\r\n\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!SpaceTokenProperties} initialProperties the initial property values\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  constructor(initialProperties: SpaceTokenProperties) {\r\n    if (initialProperties === undefined) {\r\n      super();\r\n      return;\r\n    }\r\n    else if (!(initialProperties instanceof Object))\r\n      throw new TypeError ('\"initialProperties\" isn\\'t an Object instance');\r\n    super(initialProperties); // the superclass constructor\r\n    if (initialProperties.lineBreakCount) { // if the line break number is defined\r\n      if (!isFinite(initialProperties.lineBreakCount) || initialProperties.lineBreakCount < 0)\r\n        throw new TypeError('\"initialProperties.lineBreakCount\" isn\\'t a non-negative number');\r\n      // store the line break number\r\n      Object.defineProperty(this, 'lineBreakCount', {\r\n        value: initialProperties.lineBreakCount,\r\n        enumerable: true\r\n      });\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the logical lexeme\r\n   * @return {(Lexeme|undefined)} the lexeme or undefined if the lexeme isn't defined\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get lexeme (): Lexeme {\r\n    return this.lineBreakCount <= 1 ? \"SPACE\" : \"PARAGRAPH_SEPARATOR\";\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the string representation of this node\r\n   * @param {boolean=false} skipNodeClass\r\n   *        true to not include the node class name into the output, false otherwise\r\n   * @return {string} the sources string\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  toString(skipNodeClass: boolean = false): string {\r\n    if (skipNodeClass) { // if the node class name must be skipped\r\n      switch (this.lineBreakCount) {\r\n      case 0:\r\n        return ' ';\r\n      case 1:\r\n        return '\\n';\r\n      default:\r\n        return '\\n\\n';\r\n      }\r\n    } else { // if the node class name must be included\r\n      switch (this.lineBreakCount) {\r\n      case 0:\r\n        return 'SpaceToken{ }';\r\n      case 1:\r\n        return 'SpaceToken{\\n}';\r\n      default:\r\n        return 'SpaceToken{\\n\\n}';\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nObject.defineProperties(SpaceToken.prototype, { // default properties\r\n  lineBreakCount: { value: 0, enumerable: true } // line break number\r\n});\r\n\r\n\r\n\r\n/**\r\n * LaTeX source fragment token properties\r\n * @interface SourceTokenProperties\r\n * @extends TokenProperties\r\n * @property {Lexeme} lexeme - The logical lexeme\r\n * @property {string} source - The source fragment\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface SourceTokenProperties\r\n  extends TokenProperties {\r\n  lexeme: Lexeme;\r\n  source: string;\r\n}\r\n\r\n/**\r\n * LaTeX source fragment token structure\r\n * @class\r\n * @extends Token\r\n * @property {string} source - The source fragment\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class SourceToken extends Token {\r\n  private source: string;\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!SourceTokenProperties} initialProperties the initial property values\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  constructor(initialProperties: SourceTokenProperties) {\r\n    if (!(initialProperties instanceof Object))\r\n      throw new TypeError ('\"initialProperties\" isn\\'t an Object instance');\r\n    super(initialProperties); // the superclass constructor\r\n    if (!Lexeme[initialProperties.lexeme])\r\n      throw new TypeError('\"initialProperties.lexeme\" isn\\'t known');\r\n    // store the lexeme\r\n    Object.defineProperty(this, 'lexeme', { value: initialProperties.lexeme, enumerable: true });\r\n    if (typeof initialProperties.source !== 'string')\r\n      throw new TypeError('\"initialProperties.sources\" isn\\'t a string');\r\n    // store the sources\r\n    Object.defineProperty(this, 'source', { value: initialProperties.source, enumerable: true });\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the string representation of this node\r\n   * @param {boolean=false} skipNodeClass\r\n   *        true to not include the node class name into the output, false otherwise\r\n   * @return {string} the sources string\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  toString(skipNodeClass: boolean = false) {\r\n    return skipNodeClass ? this.source : 'SourceToken[' + this.lexeme + ']{' + this.source + '}';\r\n  }\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/LatexTree.ts","/**\r\n * @fileoverview Syntax tree structure elements\r\n * This file is a part of TeXnous project.\r\n *\r\n * @copyright TeXnous project team (http://texnous.org) 2016\r\n * @license LGPL-3.0\r\n *\r\n * This library is free software; you can redistribute it and/or modify it under the terms of the\r\n * GNU Lesser General Public License as published by the Free Software Foundation; either version 3\r\n * of the License, or (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\r\n * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License along with this library;\r\n * if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\r\n * 02111-1307, USA.\r\n */\r\n\r\nimport {isNumber} from \"./Utils\";\r\n\r\n'use strict';\r\n\r\n/**@module */\r\n\r\n\r\n/**\r\n * Syntax tree structure\r\n * @class\r\n * @property {!Node} rootNode - The root node\r\n * @property {string} source - The source text\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class SyntaxTree {\r\n  //noinspection JSUnusedGlobalSymbols // TODO\r\n  readonly rootNode: Node;\r\n  readonly source: string;\r\n\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!Node} rootNode the root node (must have no parent and no tree)\r\n   * @param {string} source the sources text that has this syntax tree\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  constructor(rootNode: Node, source: string) {\r\n    if (!(rootNode instanceof Node))\r\n      throw new TypeError('\"rootNode\" isn\\'t a SyntaxTree.Node instance');\r\n    if (rootNode.parentNode) throw new TypeError('\"rootNode\" has a parent node');\r\n    if (rootNode.tree) throw new TypeError('\"rootNode\" is a tree root');\r\n\r\n    if (typeof source !== 'string')  throw new TypeError('\"sources\" isn\\'t a string');\r\n    // store the root node\r\n    Object.defineProperty(this, 'rootNode', { value: rootNode, enumerable: true });\r\n    Object.defineProperty(this, 'source', { value: source, enumerable: true }); // store the sources\r\n    // update the root node tree\r\n    Object.defineProperty(rootNode, 'tree', { value: this, enumerable: true });\r\n  }\r\n};\r\n\r\n\r\n\r\n/**\r\n * Syntax tree node properties\r\n * @interface NodeProperties\r\n * @property {(?Node|undefined)} parentNode - The parent node or undefined if there is no parent\r\n * @property {(!Array.<Node>|undefined)} childNodes - The list of the child nodes\r\n * @exports\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface NodeProperties {\r\n  parentNode?: Node;\r\n  childNodes?: Node[];\r\n}\r\n\r\n\r\n/**\r\n * Syntax tree node structure\r\n * @class\r\n * @property {?SyntaxTree} tree - The tree or undefined if this node isn't in any tree\r\n * @property {?Node} parentNode - The parent node or undefined if there is no parent\r\n * @property {!Array.<Node>} childNodes - The child node list\r\n * @property {number} subtreeSize - The size of the subtree formed by this node\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class Node {\r\n  tree: SyntaxTree;\r\n  public parentNode: Node;\r\n  private subtreeSize: number;\r\n  private childNodes_:Node[];\r\n\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!NodeProperties=} opt_initialProperties the initial property values\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  constructor(opt_initialProperties?: NodeProperties) {\r\n    if (opt_initialProperties !== undefined) { // if the initial properties are defined\r\n      if (!(opt_initialProperties instanceof Object))\r\n        throw new TypeError('initialProperties isn\\'t an Object instance');\r\n      if (opt_initialProperties.childNodes !== undefined) { // if the child node list is set\r\n        if (!(opt_initialProperties.childNodes instanceof Array))\r\n          throw new TypeError('initialProperties.childNodes isn\\'t an Array instance');\r\n        opt_initialProperties.childNodes.forEach(this.insertChildSubtree, this);\r\n      }\r\n      let optParentNode = opt_initialProperties.parentNode;\r\n      if (optParentNode !== undefined) { // if the parent node is set\r\n        if (!!optParentNode) {\r\n          //noinspection JSUnresolvedFunction\r\n          optParentNode.insertChildSubtree(this);\r\n        } else {\r\n          throw new TypeError('initialProperties.parentNode isn\\'t a SyntaxTree.Node instance');\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Get the child nodes\r\n   * @return {!Array.<Node>} the child node list\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get childNodes(): Node[] {\r\n    return this.childNodes_.slice()\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Get the child node\r\n   * @param {(!Node|number)} node the child node or its child index\r\n   * @return {?Node} the child node or undefined of there is no such a child node\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  childNode(node: Node | number): Node | undefined {\r\n    if (isNumber(node)) // if the node child index is given\r\n      return this.childNodes_[node] || undefined;\r\n    if (node instanceof Node) // if the child node is given\r\n      return node.parentNode === this ? node : undefined;\r\n    throw new TypeError('\"node\" is neither a number nor a SyntaxTree.Node instance');\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the child node index\r\n   * @param {(!Node|number)} node the child node or its child index\r\n   * @return {(number|undefined)} the child node or undefined of there is no such a child node\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  childIndex(node: Node | number): number | undefined {\r\n    if (isNumber(node)) // if the node child index is given\r\n      return this.childNodes_[node] ? node : undefined;\r\n    if (node instanceof Node) // if the child node is given\r\n      return node.parentNode === this ? this.childNodes_.indexOf(node) : undefined;\r\n    throw new TypeError('\"node\" is neither a number nor a SyntaxTree.Node instance');\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Insert a node to this child node list\r\n   * @param {!Node} node the node to insert (must have no parent and no child nodes)\r\n   * @param {number=undefined} childIndex\r\n   *        the position of the node for this child node list, the last by default\r\n   * @param {number=0} childNodesToCover\r\n   *        the number of this child nodes to become the child nodes of the new node\r\n   * @return {?Node} the inserted node or undefined if cannot insert\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  insertChildNode(node: Node, childIndex: number, childNodesToCover: number): Node {\r\n    if (!(node instanceof Node)) throw new TypeError('\"node\" isn\\'t a SyntaxTree.Node instance');\r\n    if (node.parentNode) throw new TypeError('\"node\" has a parent');\r\n    if (node.tree) throw new TypeError('\"node\" is a tree root');\r\n\r\n    // TODO\r\n    // if (!(this instanceof node.parentNodeClass_))\r\n    //   throw new TypeError('\"this\" isn\\'t a suitable class instance');\r\n\r\n    if (node.childNodes_.length) throw new TypeError('\"node\" has child nodes');\r\n    if (!this.hasOwnProperty('childNodes_')) // if there was no child nodes\r\n    // init the property\r\n      Object.defineProperty(this, 'childNodes_', { value: [], configurable: true });\r\n    // use the last position by default\r\n    if (childIndex === undefined) childIndex = this.childNodes_.length;\r\n    // do not cover any child nodes by default\r\n    if (childNodesToCover === undefined) childNodesToCover = 0;\r\n    // replace the child nodes by the new node\r\n    let nodeChildNodes = this.childNodes_.splice(childIndex, childNodesToCover, node);\r\n    // update the size of the subtree formed by this node\r\n    Object.defineProperty(this, 'subtreeSize', {\r\n      value: this.subtreeSize + 1,\r\n      enumerable: true,\r\n      configurable: true\r\n    });\r\n    // for all the parent nodes\r\n    for (let parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\r\n      // update the size of the subtree formed by the parent node\r\n      Object.defineProperty(parentNode, 'subtreeSize', { value: parentNode.subtreeSize + 1 });\r\n    }\r\n    // update the parent node of the new node\r\n    Object.defineProperty(node, 'parentNode', {\r\n      value: this,\r\n      enumerable: true,\r\n      configurable: true\r\n    });\r\n    if (nodeChildNodes.length) { // if there are child nodes for the new node\r\n      // store the child nodes\r\n      Object.defineProperty(node, 'childNodes_', { value: nodeChildNodes, configurable: true });\r\n      let subtreeSize = 1; // initiate the size of the subtree formed by the new node\r\n      // for all the child nodes of the new node\r\n      nodeChildNodes.forEach(nodeChildNode => { subtreeSize += nodeChildNode.subtreeSize });\r\n      // store the subtree size\r\n      Object.defineProperty(node, 'subtreeSize', {\r\n        value: subtreeSize,\r\n        enumerable: true,\r\n        configurable: true\r\n      });\r\n    }\r\n    return node;\r\n  }\r\n\r\n\r\n  /**\r\n   * Insert a subtree to this child node list.\r\n   * @param {!Node} node the subtree to insert root node (must have no parent)\r\n   * @param {number=} childIndex\r\n   *        the position of the subtree root for this child node list, the last by default\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  insertChildSubtree(node: Node, childIndex?: number) {\r\n    if (!(node instanceof Node))\r\n      throw new TypeError('\"node\" isn\\'t a SyntaxTree.Node instance');\r\n    if (node.parentNode) throw new TypeError('\"node\" has a parent');\r\n    if (node.tree) throw new TypeError('\"node\" is a tree root');\r\n\r\n    // todo check\r\n    // if (!(this instanceof node.parentNodeClass_))\r\n    //   throw new TypeError('\"this\" isn\\'t a suitable class instance');\r\n    // init child nodes property if not exists\r\n    if (!this.hasOwnProperty('childNodes_')) // if there was no child nodes\r\n    // init the property\r\n      Object.defineProperty(this, 'childNodes_', { value: [], configurable: true });\r\n    // use the last position by default\r\n    if (childIndex === undefined) childIndex = this.childNodes_.length;\r\n    this.childNodes_.splice(childIndex, 0, node); // insert the new node to the child list\r\n    let nodeSubtreeSize = node.subtreeSize; // the size of the subtree formed by the node\r\n    // update the size of the subtree formed by this node\r\n    Object.defineProperty(this, 'subtreeSize', {\r\n      value: this.subtreeSize + nodeSubtreeSize, enumerable: true, configurable: true\r\n    });\r\n    // for all the parent nodes\r\n    for (let parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\r\n      // update the size of the subtree formed by the parent node\r\n      Object.defineProperty(parentNode, 'subtreeSize', {\r\n        value: parentNode.subtreeSize + nodeSubtreeSize\r\n      });\r\n    }\r\n    // update the parent node of the new node\r\n    Object.defineProperty(node, 'parentNode', {\r\n      value: this,\r\n      enumerable: true,\r\n      configurable: true\r\n    });\r\n  }\r\n\r\n  \r\n\r\n  /**\r\n   * Remove a child node of this node. All its child nodes become the child nodes of this node\r\n   * @param {(!Node|number)} nodeOrNodeIndex the subtree root or its child index\r\n   * @return {?Node} the removed node or undefined of there is no such a child node\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  removeChildNode(nodeOrNodeIndex: number | Node): Node | undefined {\r\n    let nodeChildIndex: number | undefined = this.childIndex(nodeOrNodeIndex); // the child index of the node\r\n    if (nodeChildIndex === undefined) return undefined; // return if there is no such a child\r\n\r\n    const node: Node = this.childNodes_[nodeChildIndex]; // the child node to remove\r\n\r\n    // replace the node with its child nodes at this child node list\r\n    // todo could be more efficient?\r\n    this.childNodes_.splice(nodeChildIndex, 1, ...node.childNodes_);\r\n\r\n    if (this.childNodes_.length) { // if there are child nodes\r\n      // update this node subtree size\r\n      Object.defineProperty(this, 'subtreeSize', { value: this.subtreeSize - 1 });\r\n    } else { // if there are no child nodes\r\n      delete this.childNodes_; // this node has no child nodes anymore\r\n      delete this.subtreeSize; // this node has node subtree anymore\r\n    }\r\n    // for all the parent nodes\r\n    for (let parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\r\n      // update the size of the subtree formed by the parent node\r\n      Object.defineProperty(parentNode, 'subtreeSize', { value: parentNode.subtreeSize - 1 });\r\n    }\r\n    delete node.parentNode; // the node has no parent node anymore\r\n\r\n    delete node.childNodes_; // the node has no child nodes anymore\r\n    delete node.subtreeSize; // the node has no subtree anymore\r\n    return node;\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Remove a subtree formed by a child node of this node\r\n   * @param {(!Node|number)} node the subtree root or its child index\r\n   * @return {?Node} the removed subtree root node or undefined of there is no such a child node\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  removeChildSubtree(node: Node | number): Node | undefined {\r\n    let nodeChildIndex: number | undefined = this.childIndex(node); // the child index of the node\r\n    if (nodeChildIndex === undefined) return undefined; // return if there is no such a child\r\n\r\n    node = this.childNodes_.splice(nodeChildIndex, 1)[0]; // remove the node from the child list\r\n    let nodeSubtreeSize = node.subtreeSize; // the size of the subtree formed by the node\r\n    if (this.childNodes_.length) { // if there are child nodes\r\n      // update this node subtree size\r\n      Object.defineProperty(this, 'subtreeSize', { value: this.subtreeSize - nodeSubtreeSize });\r\n    } else { // if there are no child nodes\r\n      delete this.childNodes_; // this node has no child nodes anymore\r\n      delete this.subtreeSize; // this node has node subtree anymore\r\n    }\r\n    // for all the parent nodes\r\n    for (let parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\r\n      // update the size of the subtree formed by the parent node\r\n      Object.defineProperty(parentNode, 'subtreeSize', {\r\n        value: parentNode.subtreeSize - nodeSubtreeSize\r\n      });\r\n    }\r\n    delete node.parentNode; // the node has no parent node anymore\r\n    return node;\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the string representation of this node\r\n   * @param {boolean=false} skipNodeClass\r\n   *        true to not include the node class name into the output, false otherwise\r\n   * @return {string} the sources string\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  toString(skipNodeClass: boolean = false): string {\r\n    let source = ''; // the sources\r\n    // for all the child nodes\r\n    this.childNodes_.forEach(childNode => { source += childNode.toString(true) });\r\n    return skipNodeClass ? source : 'SourceTree.Node{' + source + '}';\r\n  }\r\n};\r\nObject.defineProperties(Node.prototype, { // make getters and setters enumerable\r\n  childNodes: { enumerable: true }\r\n});\r\nObject.defineProperties(Node.prototype, { // default property values\r\n  tree: { value: undefined, enumerable: true }, // no tree\r\n  parentNode: { value: undefined, enumerable: true }, // no parent node\r\n  subtreeSize: { value: 1, enumerable: true }, // only one node in the subtree\r\n  childNodes_: { value: [], enumerable: false }, // no child nodes\r\n  parentNodeClass_: { value: Node, enumerable: false } // parent node must be a Node instance\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/SyntaxTree.ts","/**\r\n * @fileoverview LaTeX parser class\r\n * This file is a part of TeXnous project.\r\n *\r\n * @copyright TeXnous project team (http://texnous.org) 2016\r\n * @license LGPL-3.0\r\n *\r\n * This library is free software; you can redistribute it and/or modify it under the terms of the\r\n * GNU Lesser General Public License as published by the Free Software Foundation; either version 3\r\n * of the License, or (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\r\n * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License along with this library;\r\n * if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\r\n * 02111-1307, USA.\r\n */\r\n\r\n/**@module */\r\n\r\n\r\nimport LatexStyle, {Symbol as SymbolItem, Command, Parameter, Environment, EnvironmentAndPackage} from \"./LatexStyle\";\r\nimport {\r\n  ParameterToken,\r\n  CommandToken,\r\n  SymbolToken,\r\n  Token,\r\n  SpaceToken,\r\n  EnvironmentToken,\r\n  EnvironmentBodyToken\r\n} from \"./LatexTree\";\r\nimport {Directive, GROUP, Lexeme, ModeStates, Operation, State} from \"./Latex\";\r\nimport {isNumber, isString, mustNotBeUndefined} from \"./Utils\";\r\n\r\n\r\n/**\r\n * Parse a comment line\r\n * @param {!Context} context the parsing context\r\n * @return {boolean} true if there was a comment line, false otherwise\r\n * @private\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nfunction parseCommentLine_(context: Context): boolean {\r\n  // try to find a comment int the sources tail\r\n  let commentMatch = context.source.substring(context.position).match(/^%([^\\n]*)(\\n[ \\t]*)?/);\r\n  if (!commentMatch) return false; // return if there is no comment at this position\r\n\r\n  context.comments.push(commentMatch[1]); // store the comment string\r\n  context.position += commentMatch[0].length; // position just after the comment\r\n  if (!commentMatch[2]) { // if there were no line breaks\r\n    context.charNumber += commentMatch[0].length; // go to the last char\r\n  } else { // if there was a line break\r\n    ++context.lineNumber; // one more line\r\n    context.charNumber = commentMatch[2].length - 1; // skip all the space chars in the new line\r\n  }\r\n  return true;\r\n}\r\n\r\n\r\n/**\r\n * Fill the parsed token position, comments and parent\r\n * @param {!Context} context the parsing context\r\n * @param {!Token} token the token to process\r\n * @private\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nfunction processParsedToken_(context: Context, token: Token) {\r\n  // TODO process comments and position\r\n  if (context.currentToken) { // if there is a current token\r\n\r\n    // console.log(context.currentToken.toString())\r\n\r\n    //noinspection JSUnresolvedFunction\r\n    context.currentToken.insertChildSubtree(token); // store this token as a child of the current\r\n  }\r\n}\r\n\r\n/**\r\n * Parse space for a token (space or paragraph separator)\r\n * @param {!Context} context the parsing context\r\n * @return {?SpaceToken} the parsed token or undefined if cannot parse a space token\r\n * @private\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nfunction parseSpaceToken_(context: Context): SpaceToken | undefined {\r\n  let isSpace = false; // true is the sources fragment is a space token, false otherwise\r\n  let nLineBreaks = 0; // number of parsed line breaks\r\n  while (context.position < context.source.length) { // while there is something to parse\r\n    // go to the next iteration if there was a comment\r\n    if (parseCommentLine_(context)) continue;\r\n    switch (context.source[context.position]) { // depend on the sources current character\r\n      case ' ': case '\\t': // if a space or a tabular\r\n      isSpace = true; // and one more parsed char\r\n      ++context.position; // go to the next sources char\r\n      ++context.charNumber; // the next char of the sources line\r\n      continue;\r\n      case '\\n': // if a line break\r\n        isSpace = true; // and one more parsed char\r\n        ++nLineBreaks; // one more parsed line\r\n        ++context.position; // go to the next sources char\r\n        ++context.lineNumber; // the next sources line\r\n        context.charNumber = 0; // the first char of the line\r\n        continue; // go to the next iteration\r\n    }\r\n    break; // stop if not a space char\r\n  }\r\n  // create a space token if needed\r\n  return isSpace ? new SpaceToken({ lineBreakCount: nLineBreaks }) : undefined;\r\n}\r\n\r\n/**\r\n * LaTeX parser structure\r\n * @class\r\n * @property {!LatexStyle} latexStyle - The LaTeX style description to be used for parsing\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class LatexParser {\r\n  latexStyle: LatexStyle;\r\n\r\n\r\n  //noinspection JSUnusedGlobalSymbols\r\n  /**\r\n   * Constructor\r\n   * @param {!LatexStyle} latexStyle LaTeX style description to be used for parsing\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  constructor(latexStyle: LatexStyle) {\r\n    if (!(latexStyle instanceof LatexStyle))\r\n      throw new TypeError('\"latexStyle\" isn\\'t a LatexStyle instance');\r\n    // store the style description\r\n    Object.defineProperty(this, 'latexStyle', { value: latexStyle, enumerable: true });\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Parse LaTeX sources\r\n   * @param {string} source the sources to parse\r\n   * @param {(!Context|undefined)} opt_context the parsing context\r\n   * @return {!Array.<!Token>} the list of the parsed tokens\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  parse(source: string, opt_context?: Context): Token[] {\r\n    if (typeof source !== 'string') throw new TypeError('\"sources\" isn\\'t a string');\r\n    let context;\r\n\r\n    if (opt_context === undefined) { // if the parsing context isn't defined\r\n      context = new Context(source); // create the context\r\n    } else if (opt_context instanceof Context) { // if the parsing context is defined\r\n      context = opt_context;\r\n      context.source += source; // update the sources\r\n    } else { // if unexpected context type\r\n      throw new TypeError('\"context\" isn\\'t a LatexParser.Context instance');\r\n    }\r\n    let parsedTokens: Token[] = []; // the list of the parsed tokens\r\n    while (true) {\r\n      let parsedToken = this.parseToken_(context);\r\n      if (parsedToken === undefined) break; // stop when cannot parse a token\r\n      parsedTokens.push(parsedToken); // store the parsed token\r\n    }\r\n    return parsedTokens;\r\n  }\r\n\r\n\r\n  /**\r\n   * Parse the next token\r\n   * @param {!Context} context the parsing context\r\n   * @return {?Token} the parsed token or undefined if the token cannot be parsed\r\n   * @private\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  parseToken_(context: Context): Token | undefined {\r\n    let token: Token | undefined = parseSpaceToken_(context); // collect comments and try to parse a space token\r\n    if (!token) { // if cannot parse a space token\r\n      if (context.position >= context.source.length) return undefined;\r\n\r\n      let contextBackup = context.copy(); // backup the current context\r\n      if (!(token = this.parseEnvironmentToken_(context))) { // if cannot parse an environment token\r\n        contextBackup.copy(context); // restore the context\r\n        if (!(token = this.parseCommandToken_(context))) { // if cannot parse a command token\r\n          contextBackup.copy(context); // restore the context\r\n          if (!(token = this.parseSymbolsToken_(context))) { // if cannot parse a symbol token\r\n            return undefined; // no token can be parsed\r\n          }\r\n        }\r\n      }\r\n    }\r\n    //noinspection JSCheckFunctionSignatures\r\n    processParsedToken_(context, token);\r\n    //noinspection JSValidateTypes\r\n    return token; // return the parsed token\r\n  }\r\n\r\n\r\n  /**\r\n   * Parse a parameter token\r\n   * @param {!Context} context the parsing context\r\n   * @param {!LatexStyle.Parameter} parameter the symbol or command parameter description\r\n   * @param {string=} opt_endLabel\r\n   *        the parameter end label or undefined if there should be a single token\r\n   * @return {?ParameterToken} the parsed parameter token or undefined if cannot parse\r\n   * @private\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  parseParameterToken_(context: Context, parameter: Parameter, opt_endLabel?: string) {\r\n    let currentTokenBackup = context.currentToken; // store the current token\r\n    //noinspection JSUnresolvedFunction,JSUnresolvedVariable\r\n    context.updateState(parameter.operations); // update the LaTeX state\r\n    if (opt_endLabel === undefined) { // if the parameter must be parsed as a single token\r\n      // has the param space prefix or not\r\n      let spacePrefixState = parseSpaceToken_(context) !== undefined;\r\n      if (context.source[context.position] === '{') { // if the parameter is bounded by brackets\r\n        // create the parameter token\r\n        context.currentToken =\r\n          new ParameterToken({ hasBrackets: true, hasSpacePrefix: spacePrefixState});\r\n        ++context.position; // go to the sources next char\r\n        ++context.charNumber; // go to the current line next char\r\n        // exit if cannot parse until the closing bracket\r\n\r\n        if (!this.parseUntilLabel_(context, '}', parameter.lexeme)) return undefined;\r\n        ++context.position; // skip the bracket in the sources\r\n        ++context.charNumber; // skip the bracket in the current line\r\n      } else { // if the parameter is't bounded by brackets\r\n        // create the parameter token\r\n        context.currentToken =\r\n          new ParameterToken({ hasBrackets: false, hasSpacePrefix: spacePrefixState});\r\n        // exit if cannot parse a parameter token\r\n        if (this.parseToken_(context) === undefined) return undefined;\r\n      }\r\n    } else { // if the parameter must be parsed until the end label\r\n      // create the parameter token\r\n      context.currentToken =\r\n        new ParameterToken({ hasBrackets: false, hasSpacePrefix: false});\r\n\r\n      // return if cannot parse\r\n      if (!this.parseUntilLabel_(context, opt_endLabel, parameter.lexeme)) return undefined;\r\n    }\r\n    let parameterToken = context.currentToken; // the parsed parameter token\r\n    context.currentToken = currentTokenBackup; // restore the current token\r\n    //noinspection JSCheckFunctionSignatures\r\n    processParsedToken_(context, parameterToken);\r\n    //noinspection JSValidateTypes\r\n    return parameterToken;\r\n  }\r\n\r\n\r\n\r\n\r\n  /**\r\n   * Parse an environment token\r\n   * @param {!Context} context the parsing context\r\n   * @return {?EnvironmentToken} the parsed token or undefined if cannot parse\r\n   * @private\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  parseEnvironmentToken_(context: Context): EnvironmentToken | undefined {\r\n    if (!context.source.startsWith('\\\\begin', context.position)) return undefined;\r\n    context.position += 6; // just after \"\\begin\"\r\n    parseSpaceToken_(context); // skip spaces\r\n    // try to obtain the environment name\r\n    let nameMatch = context.source.substring(context.position).match(/^{([\\w@]+\\*?)}/);\r\n    if (!nameMatch) return undefined; // exit if cannot bet the environment name\r\n    let name = nameMatch[1]; // the environment name\r\n    context.position += nameMatch[0].length; // skip the environment name in the sources\r\n    context.charNumber += nameMatch[0].length; // skip the environment name in the current line\r\n    let currentTokenBackup = context.currentToken; // store the current token\r\n    // try to get the corresponding environment\r\n    let environment: Environment | EnvironmentAndPackage = this.latexStyle.environments(context.currentState, name)[0];\r\n    let environmentToken = context.currentToken = environment ? // the environment token\r\n      new EnvironmentToken({ environment: environment.environment }) :\r\n      new EnvironmentToken({ name: name });\r\n    // TODO unknown environment notification\r\n    // try to parse the environment begin command\r\n    let symbols: Command[] = this.latexStyle.commands(context.currentState, name);\r\n    let beginCommandToken: Token | undefined = this.parsePatterns_(context, symbols);\r\n    if (beginCommandToken === undefined) { // if cannot parse a command\r\n      // TODO notification about the unrecognized command\r\n      // generate unrecognized command token\r\n      beginCommandToken = new CommandToken({ name: name });\r\n    }\r\n    //noinspection JSCheckFunctionSignatures\r\n    processParsedToken_(context, beginCommandToken);\r\n    let environmentBodyToken = context.currentToken = new EnvironmentBodyToken();\r\n    let endFound = this.parseUntilLabel_(context, '\\\\end{' + name + '}'); // try to get to the end\r\n    context.currentToken = environmentToken;\r\n    processParsedToken_(context, environmentBodyToken); // process the body token\r\n    let endCommandToken: Token | undefined = undefined; // the environment end command token\r\n    if (endFound) { // if the environment end was reached\r\n      context.position += name.length + 6; // skip the environment name in the sources\r\n      context.charNumber += name.length + 6; // skip the environment name in the current line\r\n      endCommandToken = this.parsePatterns_(context, this.latexStyle.commands(context.currentState, 'end' + name));\r\n    } else { // if cannot find the end of the environment\r\n      // TODO no environment end notification\r\n    }\r\n    if (endCommandToken === undefined) { // if cannot parse a command\r\n      // TODO notification about the unrecognized command\r\n      // generate unrecognized command token\r\n      endCommandToken = new CommandToken({ name: 'end' + name });\r\n    }\r\n    processParsedToken_(context, endCommandToken); // process the end command token\r\n    context.currentToken = currentTokenBackup; // restore the current token\r\n    return environmentToken;\r\n  }\r\n\r\n\r\n  /**\r\n   * Parse a command token\r\n   * @param {!Context} context the parsing context\r\n   * @return {?CommandToken} the parsed token or undefined if cannot parse\r\n   * @private\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  parseCommandToken_(context: Context): Token | undefined {\r\n    // try to find a command name\r\n    const cmdMatch = context.source.substring(context.position).match(/^\\\\([\\w@]+\\*?)/);\r\n\r\n    if (!cmdMatch)\r\n      return undefined; // exit if cannot find a command name\r\n\r\n    context.position += cmdMatch[0].length; // set position just after the command name\r\n    context.charNumber += cmdMatch[0].length; // skip all the command name chars\r\n    \r\n    // try to parse a command token\r\n    \r\n    let token: Token | undefined = this.parsePatterns_(context, this.latexStyle.commands(context.currentState, cmdMatch[1]));\r\n    if (token === undefined) { // if cannot parse a command token\r\n      // TODO notification about the unrecognized command\r\n      // generate unrecognized command token\r\n      token = new CommandToken({ name: cmdMatch[1] });\r\n    }\r\n    //noinspection JSValidateTypes\r\n    return token;\r\n  }\r\n\r\n\r\n  /**\r\n   * Parse symbols for a token\r\n   * @param {!Context} context the parsing context\r\n   * @return {?Token} the parsed token or undefined if cannot parse\r\n   * @private\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  parseSymbolsToken_(context: Context) {\r\n    // get the available symbols\r\n    let sourceCharacter = context.source[context.position]; // the current sources character\r\n    // get the symbols started with the current sources character\r\n    //noinspection JSValidateTypes\r\n    let token =\r\n      this.parsePatterns_(context, this.latexStyle.symbols(context.currentState, sourceCharacter));\r\n    if (token === undefined) { // if cannot parse a symbol token\r\n      // TODO notification about the unrecognized symbol\r\n      ++context.position; // go to the next sources character\r\n      // go to the next line character (the line is the same, \\n was parsed for a space token)\r\n      ++context.charNumber;\r\n      // generate unrecognized symbol token\r\n      token = new SymbolToken({ pattern: sourceCharacter });\r\n    } else { // if the token was parsed\r\n      // TODO parse words and numbers\r\n    }\r\n    return token;\r\n  }\r\n\r\n\r\n  /**\r\n   * Try to parse a symbol pattern\r\n   * @param {!Context} context the parsing context// generate unrecognized symbol token\r\n   * @param {!Array.<!LatexStyle.Symbol>} symbols the symbol or command descriptions in the priority descending order\r\n   * @return {?Token} the parsed symbol or command token or undefined if cannot parse\r\n   * @private\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  parsePatterns_(context: Context, symbols: SymbolItem[]): Token | undefined {\r\n    let contextBackup = context.copy(); // backup the current context\r\n    let token: Token | undefined = undefined; // the parsed token\r\n\r\n    // TODO not how some() is meant to be used...?\r\n    symbols.some(symbol => { // for all the symbols until the parsing success\r\n      // stop if the token was parsed\r\n      if (token = this.parsePattern_(context, symbol)) {\r\n        return true;\r\n      } else {\r\n        contextBackup.copy(context); // restore the context\r\n        return false; // go to the next symbol\r\n      }\r\n    });\r\n    return token;\r\n  }\r\n\r\n\r\n  /**\r\n   * Try to parse a symbol pattern\r\n   * @param {!Context} context the parsing context\r\n   * @param {!Array.<!LatexStyle.Symbol>} symbol the symbol or command description\r\n   * @return {?Token} the parsed symbol or command token or undefined if cannot parse\r\n   * @private\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  parsePattern_(context: Context, symbol: SymbolItem): Token | undefined {\r\n    let currentTokenBackup = context.currentToken; // store the current token\r\n    // if a command description is given\r\n    context.currentToken = symbol instanceof Command ?\r\n      new CommandToken({ command: symbol }) : // generate a command token\r\n      new SymbolToken({ symbol: symbol }); // generate a symbol token\r\n\r\n    let patternComponents = symbol.patternComponents; // the symbol pattern components\r\n    let nPatternComponents = patternComponents.length; // the pattern componen number\r\n    let iPatternComponent = 0; // the pattern component iterator\r\n    // for all the pattern components\r\n    for ( ; iPatternComponent < nPatternComponents; ++iPatternComponent) {\r\n      let patternComponent = patternComponents[iPatternComponent]; // the pattern component\r\n      if(isNumber(patternComponent)){ // if a parameter is expected\r\n        let parameter: Parameter | undefined = symbol.parameter(patternComponent); // the parameter description\r\n        // try to get the end label for the parameter\r\n        let parameterEndLabel = patternComponents[iPatternComponent + 1];\r\n        if (typeof parameterEndLabel === 'string') { // if there is a end label\r\n          // if can parse the parameter token\r\n          if (this.parseParameterToken_(context, mustNotBeUndefined(parameter), parameterEndLabel)) {\r\n            // exit if there is no the end label at the positions\r\n            if (!context.source.startsWith(parameterEndLabel, context.position)) return undefined;\r\n            context.position += parameterEndLabel.length; // skip the end label in the sources\r\n            context.charNumber += parameterEndLabel.length; // skip the end label in the line\r\n            ++iPatternComponent; // skip the end label in the pattern\r\n            continue; // go to the next pattern component\r\n          }\r\n        } else { // if there is no a end label\r\n          // go to the next pattern char if can parse the parameter token\r\n          if (this.parseParameterToken_(context, mustNotBeUndefined(parameter))) continue;\r\n        }\r\n      }\r\n      else if(isString(patternComponent)){\r\n          while (parseCommentLine_(context)) {\r\n          } // skip all the comments\r\n          // if the sources fragment is equal the pattern component\r\n          if (context.source.startsWith(patternComponent, context.position)) {\r\n            context.position += patternComponent.length; // skip the pattern component in the sources\r\n            context.charNumber += patternComponent.length; // skip the pattern component in the line\r\n            continue; // go to the next pattern component\r\n          }\r\n      } else if (parseSpaceToken_(context))\r\n        continue;\r\n      break; // stop parsing if there was no continue call\r\n    }\r\n    // return if the pattern parsing was broken\r\n    if (iPatternComponent < nPatternComponents) return undefined;\r\n    let parsedToken = context.currentToken; // the parsed token to return\r\n    context.currentToken = currentTokenBackup; // restore the current token\r\n    //noinspection JSUnresolvedFunction,JSUnresolvedVariable\r\n    context.updateState(symbol.operations); // update the LaTeX state\r\n    return parsedToken;\r\n  }\r\n\r\n\r\n  /**\r\n   * Parse tokens until the label\r\n   * @param {!Context} context the parsing context\r\n   * @param {string} endLabel the label to parse until\r\n   * @param {Latex.Lexeme=} opt_lexeme the lexeme of the single token to parse\r\n   * @return {boolean} true if the parsing was successful, false otherwise\r\n   * @private\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  parseUntilLabel_(context: Context, endLabel: string, opt_lexeme?: Lexeme) {\r\n    switch (opt_lexeme) {\r\n      // TODO parse special lexemes\r\n    default: {\r\n      // while not reached the label\r\n      while (!context.source.startsWith(endLabel, context.position)) {\r\n        if (context.position >= context.source.length) { // if there is no more sources\r\n          // TODO notification about unexpected sources end\r\n          return false;\r\n        }\r\n        this.parseToken_(context);\r\n      }\r\n      return true;\r\n    }}\r\n  }\r\n};\r\n\r\n\r\n\r\n/**\r\n * The parsing context\r\n * @struct\r\n * @property {string} source - The source to parse\r\n * @property {number} position - The current position in the source\r\n * @property {?Token} currentToken - The currently parsing token\r\n * @property {!Latex.State} currentState - The current LaTeX state\r\n * @property {!Array.<!Latex.State>} stateStack - The stack of LaTeX sates\r\n * @property {!Array.<string>} comments - The comment list for the nex token\r\n * @property {number} lineNumber - The current line number\r\n * @property {number} charNumber - The current char number in the current line\r\n * @property {function} copy\r\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n */\r\nexport class Context {\r\n  source: string;\r\n  position: number;\r\n  currentToken?: Token;\r\n  currentState: State;\r\n  stateStack: State[];\r\n  comments: string[];\r\n  lineNumber: number;\r\n  charNumber: number;\r\n\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {string=} opt_source the sources to parse (empty string by default)\r\n   */\r\n  constructor(opt_source: string = \"\") {\r\n    this.source = opt_source || ''; // store the sources\r\n    this.position = 0; // start from the beginning\r\n    this.lineNumber = 0; // start from the line 0\r\n    this.charNumber = 0; // start from the char 0\r\n    this.currentToken = undefined; // no tokens were parsed\r\n    this.currentState = new State(); // initial LaTeX state\r\n    this.stateStack = []; // no stored states\r\n    this.comments = []; // no comments for the next token\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Copy this context\r\n   * @param {!Context=} opt_target the context to copy to or undefined to create a new one\r\n   * @return {!Context} the context copy\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  copy(opt_target?: Context): Context {\r\n    let target = opt_target || new Context(); // the context to copy this context in\r\n    target.source = this.source;\r\n    target.position = this.position;\r\n    target.lineNumber = this.lineNumber;\r\n    target.charNumber = this.charNumber;\r\n    target.currentToken = this.currentToken;\r\n    target.currentState = this.currentState.copy();\r\n    target.stateStack = this.stateStack.slice();\r\n    target.comments = this.comments.slice();\r\n    return target;\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Update the LaTeX state\r\n   * @param {!Array.<!Latex.Operation>} operations the LaTeX operation list\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  updateState(operations: Operation[]) {\r\n    if (!(operations instanceof Array))\r\n      throw new TypeError('\"operations\" isn\\'t an Array instance');\r\n    let newModeStates: ModeStates = {}; // the modes to update\r\n    operations.forEach((operation: Operation) => {\r\n\r\n      switch (operation.directive) {\r\n      case Directive.BEGIN:\r\n\r\n        switch (operation.operand) {\r\n        case GROUP:\r\n          this.currentState.update(newModeStates); // store the mode states\r\n          newModeStates = {}; // no more states to update\r\n          this.stateStack.push(this.currentState.copy()); // store the current state\r\n          break;\r\n        default:\r\n\r\n          newModeStates[operation.operand] = true; // turn the state on\r\n        }\r\n        break;\r\n      case Directive.END:\r\n\r\n        switch (operation.operand) {\r\n        case GROUP:\r\n          newModeStates = {}; // no need to store the states\r\n          if (this.stateStack.length < 1) throw new Error('state stack is empty');\r\n          this.currentState = mustNotBeUndefined(this.stateStack.pop()); // restore the current state\r\n          break;\r\n        default:\r\n\r\n          newModeStates[operation.operand] = false; // turn the state off\r\n        }\r\n        break;\r\n      }\r\n    });\r\n    this.currentState.update(newModeStates); // store the mode states\r\n  }\r\n};\r\n\r\n//noinspection JSUnusedGlobalSymbols // TODO\r\nexport default LatexParser;\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/LatexParser.ts","/**\r\n * @fileoverview Export file for LaTeX parser utilities.\r\n * This file is a part of TeXnous project.\r\n *\r\n * @copyright TeXnous project team (http://texnous.org) 2016\r\n * @license LGPL-3.0\r\n *\r\n * This library is free software; you can redistribute it and/or modify it under the terms of the\r\n * GNU Lesser General Public License as published by the Free Software Foundation; either version 3\r\n * of the License, or (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\r\n * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License along with this library;\r\n * if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\r\n * 02111-1307, USA.\r\n */\r\n\r\nexport * from \"./lib/Utils\" // general JavaScript utils\r\nexport * from \"./lib/Latex\" // general LaTeX definitions\r\nexport * from \"./lib/LatexStyle\" // LaTeX style structures\r\nexport * from \"./lib/SyntaxTree\" // syntax tree structure elements\r\nexport * from \"./lib/LatexTree\" // LaTeX syntax tree structure elements\r\nexport * from \"./lib/LatexParser\"// LaTeX parser class\n\n\n// WEBPACK FOOTER //\n// ./sources/main.ts"],"sourceRoot":""}